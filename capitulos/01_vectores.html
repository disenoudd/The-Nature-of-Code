<section data-type="chapter" id="_chapter_1_vectors">
<h1>Capítulo 1. Vectores</h1>

<blockquote data-type="epigraph">
<p>“Roger, Roger. ¿Cuál es nuestro vector, Víctor?</p>

<p data-type="attribution">— Capitán Oveur (Aeroplano)</p>
</blockquote>

<a data-primary="vectors" data-type="indexterm"></a>

<p>Este libro se trata sobre mirar el mundo nuestro alrededor y encontrar maneras inteligentes de simular ese mundo con código. Dividido en tres partes, el libro comienza con un poco de física básica – cómo cae una manzana desde un árbol, cómo se balancea un péndulo, cómo la Tierra rota alrededor del Sol, etc. Absolutamente todo el contenido de los primeros cinco capítulos del libro requieren usar el bloque más básico para programar movimiento – el <strong><em>vector</em></strong>. Y así pues, aquí comenzamos nuestra historia.</p>

<a data-primary="Euclid" data-type="indexterm"></a> <a data-primary="Euclidean vector" data-type="indexterm"></a> <a data-primary="geometric vector" data-type="indexterm"></a> <a data-primary="vectors" data-secondary="defined" data-type="indexterm"></a>

<p>Ahora bien, la palabra vector puede significar muchas cosas diferentes. Vector es el nombre de una banda de música <em>New Wave</em> formada en Sacramento, CA a principios de 1980. Es el nombre de un cereal de desayuno fabricado por Kellogg Canadá. En el campo de la epidemiología, un vector se utiliza para describir al organismo que transmite una infección de un huésped a otro. En la programación C++, un vector (std :: vector) es una implementación de una estructura de datos del tipo Array, de tamaño dinámicamente variable. Si bien todas estas definiciones son interesantes, no son lo que estamos buscando. Lo que buscamos se llama <strong><em>Vector Euclideano</em></strong> (llamado así por el matemático griego Euclides y también conocido como un vector geométrico). Cuando veas el término "vector" en este libro, puedes asumir que se refiere a un Vector Euclideano, que se define como <em>una entidad que tiene tanto magnitud como dirección</em>.</p>

<a data-primary="vectors" data-secondary="notation" data-type="indexterm"></a>

<p>Un vector típicamente se dibuja como una flecha; la dirección se indica con la punta de la flecha y su magnitud por el largo del cuerpo de la misma.</p>

<figure id="chapter01_figure1"><img alt="Figure 1.1" src="chapter01/ch01_01.png" />
<figcaption>Figura 1.1 Un Vector (dibujado como una flecha) tiene magnitud (largo de la flecha) y dirección (hacia dónde apunta).</figcaption>
</figure>

<p>En esta ilustración, el vector se dibuja como una flecha desde el punto A hacia el punto B, y sirve como instrucción para el desplazamiento desde A hacia B.</p>

<section data-type="sect1" id="chapter01_section1">
<h2>1.1 Vectores, Son mi media naranja</h2>

<a data-primary="bouncing ball sketch" data-type="indexterm"></a> <a data-primary="vectors" data-secondary="bouncing ball sketch" data-type="indexterm"></a>

<p>Antes de entrar en más detalles sobre los vectores, miremos un ejemplo básico de Processing que demuestra por qué debiéramos preocuparnos de ellos en primer lugar. Si ya leíste cualquiera de los libros introductorios a Processing, o tomaste una clase de programación con Processing (si ya haz hecho alguna de esas dos cosas como preparación para este libro, mucho mejor), es probable que ya hayas aprendido a escribir un <em>sketch</em> sencillo (sketch es el documento donde escribimos el código dentro de Processing) con una pelota saltarina.</p>

<figure class="screenshot" data-pde="processingjs/chapter01/_1_1_bouncingball_novectors/_1_1_bouncingball_novectors.pde"><img alt="" src="chapter01/ch01_ex01.png" />
<figcaption>Si estás leyendo este libro impreso o en PDF, sólo verás las imágenes estáticas. El movimiento, claramente, es un elemento clave de nuestra discusión, por lo que dentro de lo posible los pantallazos estáticos tendrán un rastro traslúcido para dar cuenta de ese comportamiento. Para saber más sobre cómo dibujar esos rastros, ve el código de ejemplo disponible para descargar.</figcaption>
</figure>

<div data-type="example"><h5>Ejemplo 1.1: Pelota saltarina sin vectores</h5></div>

<pre data-code-language="java" data-type="programlisting" class="codesplit">
// Variables para ubicación y velocidad de la pelota.
float x = 100;
float y = 100;
float velocidadX = 1;
float velocidadY = 3.3;

//{!4} ¿Recuerdas cómo funciona Processing? El setup() es ejecutado una vez cuando el sketch comienza a correr, y el draw() se ejecuta en bucle por siempre (hasta que cierres la ventana)
void setup() {
  size(640,360);
  background(255);
}

void draw() {
  background(255);

  // Mueve la pelota dependiendo de su velocidad.
  x = x + velocidadX;
  y = y + velocidadY;

  // {!6} Revisa el rebote.
  if ((x > width) || (x < 0)) {
    velocidadX = velocidadX * -1;
  }
  if ((y > height) || (y < 0)) {
    velocidadY = velocidadY * -1;
  }

  stroke(0);
  fill(175);
  // {!1} Muestra la pelota en su ubicación (x,y).
  ellipse(x,y,16,16);
}</pre>

<p>En el ejemplo anterior, tenemos un mundo muy simple —un lienzo en blanco con una figura circular (una "pelota") moviéndose. Esta pelota tiene algunas propiedades, las cuales están representadas en el código como variables.</p>

<div data-type="note">
<dl>
	<dt>Ubicación</dt>
	<dd>
	<p><em>x e y</em></p>
	</dd>
	<dt>Velocidad</dt>
	<dd>
	<p><em>velocidadX and velocidadY</em></p>
	</dd>
</dl>
</div>

<p>En un sketch más avanzado, podríamos imaginarnos teniendo más variables:</p>

<div data-type="note">
<dl>
	<dt>Aceleración</dt>
	<dd>
	<p><em>aceleracionX e aceleracionY</em></p>
	</dd>
	<dt>Ubicación del objetivo</dt>
	<dd>
	<p><em>objetivoX y objetivoY</em></p>
	</dd>
	<dt>Viento</dt>
	<dd>
	<p><em>vientoX y vientoY</em></p>
	</dd>
	<dt>Fricción</dt>
	<dd>
	<p><em>friccionX y friccionY</em></p>
	</dd>
</dl>
</div>

<p>Está quedando cada vez más claro, que para cada concepto en este mundo (viento, ubicación, aceleración, etc.), necesitaremos dos variables. Y esto es sólo un mundo bidimensional. En un mundo tridimensional, necesitaremos <code>x</code>, <code>y</code>, <code>z</code>, <code>velocidadX</code>, <code>velocidadY</code>, <code>velocidadZ</code>, etc.</p>

<p>¿No sería agradable poder simplificar nuestro códgio y usar menos variables?</p>

<p>En vez de:</p>

<pre data-code-language="java" data-type="programlisting" class="codesplit">
float x;
float y;
float velocidadX;
float velocidadY;</pre>

<p>Podríamos simplemente tener…</p>

<pre data-code-language="java" data-type="programlisting" class="codesplit">
Vector ubicacion;
Vector velocidad;</pre>

<p>Dar este primer paso en el uso de vectores no nos permitirá hacer nada nuevo. Tan sólo añadiendo vectores no hará que mágicamente nuestro sketch de Processing simule la física. Sin embargo, ellos simplificarán tu código y te proporcionarán un conjunto de funciones para operaciones matemáticas comunes que suceden una y otra vez mientras programas el movimiento.</p>

<p>Como una introducción a los vectores, viviremos en dos dimensiones por un tiempo (al menos hasta que pasemos los primeros capítulos). Todos estos ejemplos pueden extenderse fácilmente a tres dimensiones (y la Clase que usaremos—<span>PVector</span><code>—</code>nos permite usar tres dimensiones.) Sin embargo, es más fácil empezar con solamente dos.</p>
</section>

<section data-type="sect1" id="chapter01_section2">
<h2>1.2 Vectores para Programadores con Processing</h2>

<a data-primary="Processing" data-secondary="vectors and" data-type="indexterm"></a> <a data-primary="PVector class (Processing)" data-type="indexterm"></a> <a data-primary="vectors" data-secondary="Processing and" data-type="indexterm"></a>

<p>Una manera de ver a los vectores es como la diferencia entre dos puntos. Considerando cómo podrías dar instrucciones para caminar de un punto a otro.</p>

<p>Aquí hay algunos vectores y posible traslaciones:</p>

<figure id="chapter01_figure2"><img alt="Figure 1.2" src="chapter01/ch01_02.png" />
<figcaption>Figura 1.2</figcaption>
</figure>

<div data-type="note">
<dl>
	<dt>(-15, 3)</dt>
	<dd>
	<p><em>Avanza quince pasos al oeste; gira y avanza tres pasos al norte.</em></p>
	</dd>
	<dt>(3, 4)</dt>
	<dd>
	<p><em>Avanza tres pasos al este; gira y avanza cinco pasos al norte.</em></p>
	</dd>
	<dt>(2, -1)</dt>
	<dd>
	<p><em>Avanza dos pasos al este; gira y avanza un paso al sur.</em></p>
	</dd>
</dl>
</div>

<p>Probablemente haz hecho algo similar al programar movimiento. Por cada cuadro de animación(ej: un único ciclo de bucle del<code>draw()</code> de processing), tu instruyes cada objeto en a pantalla para mover cierto numero de pixeles horizonta y verticalmente.</p>

<figure id="chapter01_figure3"><img alt="Figure 1.3" src="chapter01/ch01_03.png" />
<figcaption>Figura 1.3</figcaption>
</figure>

<p>Por cada cuadro:</p>

<p><strong><em>nueva ubicación = velocidad aplicada a la ubicación actual</em></strong></p>

<a data-primary="locations" data-secondary="as vectors" data-type="indexterm"></a> <a data-primary="vectors" data-secondary="locations and" data-type="indexterm"></a> <a data-primary="vectors" data-secondary="velocity and" data-type="indexterm"></a> <a data-primary="velocity" data-secondary="as vector" data-type="indexterm"></a>

<p>Si velocidad es un vector (la diferencia entre dos puntos), entonces ¿qué es ubicación? Y ¿qué es un vector? Técnicamente, podríamos argumentar que la posición no es un vector, ya que describe cómo moverse de un punto a otro - sólo describe un punto individual en el espacio.</p>

<p>Sin embargo, otra forma de describir una ubicación, es el camino desde el origen hasta llegar a esa ubicación. Por lo tanto, una ubicación puede ser el vector representando la diferencia entre ubicación y origen.</p>

<figure id="chapter01_figure4"><img alt="Figure 1.4" src="chapter01/ch01_04.png" />
<figcaption>Figura 1.4</figcaption>
</figure>

<p>Examinemos datos subyacentes para ambas, ubicación y velocidad. En el ejemplo de la pelota que rebota teníamos los siguiente:</p>

<div data-type="note">
<dl>
	<dt>Ubicación</dt>
	<dd>
	<p><em>x,y</em></p>
	</dd>
	<dt>Velocidad</dt>
	<dd>
	<p><em>velocidadX,velocidadY</em></p>
	</dd>
</dl>
</div>

<p>Notemos como estamos almacenando la misma información para ambas- dos números de punto flotante, ambas <code>x</code> e <code>y</code>. Si fuéramos a escribir una clase vector, comenzaríamos con algo bastante básico: </p>

<pre data-code-language="java" data-type="programlisting" class="codesplit">
class PVector {

  float x;
  float y;

  PVector(float x_, float y_) {
    x = x_;
    y = y_;
  }

}</pre>

<p>En su esencia, un <code>PVector</code> es sólo una manera conveniente de almacenar dos valores (o tres, como se puede ver en ejemplos 3D).</p>

<p>Y así esto…</p>

<pre data-code-language="java" data-type="programlisting" class="codesplit">
float x = 100;
float y = 100;
float velocidadX = 1;
float velocidadY = 3.3;</pre>

<p>Se transforma en esto…</p>

<pre data-code-language="java" data-type="programlisting" class="codesplit">
PVector ubicacion = new PVector(100,100);
PVector velocidad = new PVector(1,3.3);</pre>

<a data-primary="vectors" data-secondary="motion" data-tertiary="implementing with" data-type="indexterm"></a>

<p>Ahora que tenemos dos objetos tipo vector (ubicacion y velocidad), estamos listsos para implementar un algoritmo para el movimiento - <strong><em>ubicacion = ubicacion + velocidad</em></strong>. En el ejemplo 1.1, sin vectores, teníamos:</p>

<pre data-code-language="java" data-type="programlisting" class="codesplit">
// Agrega cada velocidad a cada ubicacióm
x = x + velocidadX;
y = y + velocidadY;</pre>

<p>En un miundo ideal, podríamos reescribir lo anterior de esta forma:</p>

<pre data-code-language="java" data-type="programlisting" class="codesplit">
// Agrega el vector de velocidad al vector de ubicación
ubicacion = ubicacion + velocidad;</pre>

<a data-primary="addition operator" data-type="indexterm"></a>

<p>Sin embargo, en Processing, la operación matemática de adición + está reservada para valores primitivos (enteros, decimales, etc.) únicamente. Processing no sabe cómo sumar objetos tipo <code>PVector</code>, tal como no sabe sumar objetos tipo <code>PFont</code> o tipo <code>PImage</code>. Afortunadamente para nosotros, la clase <code>PVector</code> incluye funciones para las operaciones matemáticas más comunes.</p>
</section>

<section data-type="sect1" id="chapter01_section3">
<h2>1.3 Adición de Vectores</h2>

<a data-primary="add() function (PVector class)" data-type="indexterm"></a> <a data-primary="vectors" data-secondary="adding" data-type="indexterm"></a>

<p>Antes de que continuemos viendo la clase <code>PVector</code> y su método <code>add()</code> (puramente por el bien de aprender puesto que ya está implementado para nosotros en Processing), examinemos la adición de vectores usando una notación encontrada en libros de matemáticas y física.</p>

<a data-primary="scalar notation" data-secondary="vs. vector notation" data-type="indexterm"></a> <a data-primary="vector notation" data-secondary="vs. scalar notation" data-type="indexterm"></a>

<p>Los vectores están generalmente escritos en negrita o con una flecha por encima. Para el propósito de este libro, para distinguir un <strong><em>vector</em></strong> de un <strong><em>escalar</em></strong> (un <em>escalar</em> se refiere a un único valor, ya sea un número entero o un número de punto flotante), usaremos la notación con flecha:</p>

<ul>
	<li>
	<p>Vector: <span data-type="equation">\vec{v}</span></p>
	</li>
	<li>
	<p>Escalar: <span data-type="equation">{x}</span></p>
	</li>
</ul>

<p>Digamos que tenemos los siguientes dos vectores:</p>

<figure id="chapter01_figure5"><img alt="Figure 1.5" src="chapter01/ch01_05.png" />
<figcaption>Figura 1.5</figcaption>
</figure>

<p>Cada vector tiene dos componentes, un valor <code>x</code> y un <code>y</code>. Para sumar dos vectores, simplemente tenemos que sumar ambas <code>x</code><code>’</code>s y ambas <code>y</code><code>’</code>s.</p>

<figure id="chapter01_figure6"><img alt="Figure 1.6" src="chapter01/ch01_06.png" />
<figcaption>Figura 1.6</figcaption>
</figure>

<p>En otras palabras:</p>

<div class="equation-left">
<div data-type="equation">\vec{w} = \vec{u} + \vec{v}</div>
</div>

<p>lo podemos escribir como:</p>

<div class="narrow equation-left">
<div data-type="equation">w_x = u_x - v_x</div>
<div data-type="equation">w_y = u_y - v_y</div>
</div>

<p>En,tonces reemplazando <code>u</code> y <code>v</code> con sus valores desde la Figura 1.6, obtenemos:</p>

<div class="narrow equation-left">
<div data-type="equation">w_x = 5 + 3</div>
<div data-type="equation">w_y = 2 + 4</div>
</div>

<p>lo que significa que:</p>

<div class="narrow equation-left">
<div data-type="equation">w_x = 8</div>
<div data-type="equation">w_y = 6</div>
</div>

<p>Entonces, esto lo escribimos como un vector:</p>

<div class="equation-left">
<div data-type="equation">\vec{w} = (8,6)</div>
</div>

<a data-primary="add() function (PVector class)" data-secondary="implementation of" data-type="indexterm"></a>

<p>Ahora que entendemos cómo sumar dos vectores, podemos ver cómo la adición es implementada en la clase <code>PVector</code>. Escribamos una función llamada <code>add()</code> que toma como argumento otro objeto <code>PVector</code>.</p>

<pre data-code-language="java" data-type="programlisting" class="codesplit">
class PVector {

  float x;
  float y;

  PVector(float x_, float y_) {
    x = x_;
    y = y_;
  }

  // {!4 .bold} Nuevo! Una función para sumar otro PVector a este PVector. Simplemente suma los componentes de <em>x</em> y los componentes de <em>y</em>.
  void add(PVector v) {
    y = y + v.y;
    x = x + v.x;
  }
}</pre>

<div data-type="note">
<h2>Propiedades Básicas de los Números con Vectores</h2>

<p>La adición con vectores sigue las mismas reglas algebraicas que con números reales..</p>

<p><strong><em>Regla de Conmutatividad</em></strong> <span data-type="equation">\vec{u} + \vec{v} = \vec{v} + \vec{u}</span><br />
<strong><em>Regla de Asociatividad:</em></strong> <span data-type="equation">\vec{u} + (\vec{v} + \vec{w}) = (\vec{u} + \vec{v}) + \vec{w}</span></p>

<p>Dejando de lado la terminología y los símbolos, este es un concepto realmente simple. Sólo estamos diciendo que algunas propiedades de sentido común de la suma, también son válidas con los vectores.</p>

<div class="narrow">
<div data-type="equation">3 + 2 = 2 + 3</div>
<div data-type="equation">(3 + 2) + 1 = 3 + (2 + 1)</div>
</div>

</div>

<a data-primary="bouncing ball sketch" data-secondary="implementing with vectors" data-type="indexterm"></a>

<p>Ahora que vimos cómo <code>add()</code> está escrita dentro de <code>PVector</code>, podemos volver a nuestro ejemplo de la pelota saltarina con su algoritmo de <strong><em>ubicación + velocidad</em></strong> e implementarle una adición de vectores:</p>

<pre data-code-language="java" data-type="programlisting" class="codesplit">
// {!1 .line-through}Suma la velocidad actual a la ubicación.
ubicacion = ubicacion + velocidad;
ubicacion.add(velocidad);</pre>

<p>Y aquí estamos listos para reescribir el ejemplo de la pelota saltarina usando <code>PVector</code>.</p>

<a data-primary="dot syntax" data-type="indexterm"></a> <a data-primary="object-oriented programming" data-secondary="dot syntax" data-type="indexterm"></a>

<div data-type="example"><h5>Ejemplo 1.2: ¡Pelota saltarina con PVectors!</h5></div>

<pre data-code-language="java" data-type="programlisting" class="codesplit">
//{!2 .bold} En vez de muchos floats, ahora tenemos solo dos variables PVector.
PVector ubicacion;
PVector velocidad;

void setup() {
  size(640,360);
  //{!2 .bold .no-comment}
  ubicacion = new PVector(100, 100);
  velocidad = new PVector(2.5, 5);
}

void draw() {
  background(255);
  //{!1 .bold .no-comment}
  ubicacion.add(velocidad);

  //{!6 .bold} A veces, aún necesitaremos referirnos a los componentes individuales de un PVector. Para hacerlo se debe nombrar el objeto, seguido por un punto, y finalmente nombrar el componente al cual se quiere acceder; conocido como notación de punto: ubicacion.x, velocidad.y, etc.
  if ((ubicacion.x > width) || (ubicacion.x < 0)) {
    velocidad.x = velocidad.x * -1;
  }
  if ((ubicacion.y > height) || (ubicacion.y < 0)) {
    velocidad.y = velocidad.y * -1;
  }

  stroke(0);
  fill(175);
  ellipse(ubicacion.x, ubicacion.y, 16, 16);
}</pre>

<p>Ahora, podrías sentirte un poco decepcionado. Después de todo, esto podría parecer que inicialmente hizo el código más complicado que la versión original. Aunque esta es una crítica perfectamente razonable, es importante entender que todavía no nos hemos dado cuenta realmente del poder de programar con vectores. Mirar una simple pelota saltarina e implementar la suma de vectores, es sólo el primer paso. Mientras nos adentramos en un mundo mucho más complejo de múltiples objetos y múltiples <strong><em>fuerzas</em></strong> (las cuales introduciremos en el Capítulo 2), los beneficios de <code>PVector</code> se harán notar cada vez más.</p>

<p>Sin embargo, debemos notar un aspecto importante de la transición a programar con vectores. Aunque estamos usando objetos <code>PVector</code> para describir los valores —la <code>x</code> e <code>y</code> de ubicación y la <code>x</code> e <code>y</code> de velocidad— todavía necesitaremos referirnos a los componentes <em>x</em> e <em>y</em> de cada <code>PVector</code> individualmente. Cuando vayamos a Processing para dibujar un objeto, no hay necesidad de decir:</p>

<pre data-code-language="java" data-type="programlisting" class="codesplit">
// {.line-through .no-comment}
ellipse(ubicacion, 16, 16);</pre>

<p>La función <code>ellipse()</code> no permite usar un <code>PVector</code> como argumento. Una elipse puede ser dibujada sólo con dos valores escalares, una coordenada en <code>x</code> y una coordenada en <code>y</code>. Entonces debemos meternos dentro del objeto <code>PVector</code> y sacar los componentes <em>x</em> e <em>y</em> usando la <em>notación de punto</em> orientada a objetos.</p>

<pre data-code-language="java" data-type="programlisting" class="codesplit">
ellipse(ubicacion.x, ubicacion.y, 16, 16);</pre>

<p>La misma cuestión surge cuando probamos si el círculo ha llegado al borde de la ventana, y debemos acceder a los componentes individuales de ambos vectores: <code>ubicacion</code> y <code>velocidad</code>.</p>

<pre data-code-language="java" data-type="programlisting" class="codesplit">
if ((ubicacion.x > width) || (ubicacion.x < 0)) {
  velocidad.x = velocidad.x * -1;
}</pre>

<div data-type="exercise" id="chapter01_exercise1">
<h5>Ejercicio 1.1</h5>

<p>Encuentra algo que hayas hecho previamente en Processing usando variables separadas de <code>x</code> e <code>y</code>, y en lugar de ellas usa <code>PVector</code><code>s</code>.</p>
</div>

<div data-type="exercise" id="chapter01_exercise2">
<h5>Ejercicio 1.2</h5>

<p>Usa uno de los ejemplos de Caminante de la introducción y conviértelo para que use <code>PVector</code><code>s</code>.</p>
</div>

<div data-type="exercise" id="chapter01_exercise3">
<h5>Ejercicio 1.3</h5>

<p>Extiende a 3D el ejemplo de la pelota saltarina con vectores. ¿Podrías hacer que la esfera rebote alrededor de una caja?</p>
</div>
</section>

<section data-type="sect1" id="chapter01_section4">
<h2>1.4 Más Matemática de Vectores</h2>

<p>En realidad, la adición fue sólo el primer paso. Hay muchas operaciones matemáticas que son comúnmente usadas con vectores. Abajo, hay una lista exhaustiva de las operaciones disponibles como funciones en la clase <code>PVector</code>. Repasaremos algunas de las más relevantes ahora. En cuanto nuestros ejemplos se hagan más sofisticados en los próximos capítulos, revelaremos los detalles de más funciones.</p>

<a data-primary="PVector class (Processing)" data-secondary="mathematical functions for" data-type="indexterm"></a> <a data-primary="angleBetween() function (PVector class)" data-type="indexterm"></a> <a data-primary="cross() function (PVector class)" data-type="indexterm"></a> <a data-primary="dist() function (PVector class)" data-type="indexterm"></a> <a data-primary="dot() function (PVector class)" data-type="indexterm"></a> <a data-primary="heading() function (PVector class)" data-type="indexterm"></a> <a data-primary="lerp() function (PVector class)" data-type="indexterm"></a> <a data-primary="limit() function (PVector class)" data-type="indexterm"></a> <a data-primary="PVector class (Processing)" data-secondary="function list for" data-type="indexterm"></a> <a data-primary="random2D() function (PVector class)" data-type="indexterm"></a> <a data-primary="random3D() function (PVector class)" data-type="indexterm"></a> <a data-primary="rotate() function (PVector class)" data-type="indexterm"></a>

<ul>
	<li>
	<p><code>add()</code> — suma vectores</p>
	</li>
	<li>
	<p><code>sub()</code> — resta vectores</p>
	</li>
	<li>
	<p><code>mult()</code> — escala los vectores con multiplicación</p>
	</li>
	<li>
	<p><code>div()</code> — escala los vectores con división</p>
	</li>
	<li>
	<p><code>mag()</code> — calcula la magnitud de un vector</p>
	</li>
	<li>
	<p><code>setMag()</code> - define la magnitud de un vector</p>
	</li>
	<li>
	<p><code>normalize()</code> — normaliza el vector a una longitud de 1</p>
	</li>
	<li>
	<p><code>limit()</code> — limita la magnitud de un vector</p>
	</li>
	<li>
	<p><code>heading()</code> — el inicio de un vector 2D expresado como un ángulo</p>
	</li>
	<li>
	<p><code>rotate()</code> — rota un vector 2D por un ángulo</p>
	</li>
	<li>
	<p><code>lerp()</code> — interpolar linealmente a otro vector</p>
	</li>
	<li>
	<p><code>dist()</code> — distancia Euclidiana entre dos vectores (considerados como puntos)</p>
	</li>
	<li>
	<p><code>angleBetween()</code> — encuentra el ángulo entre dos vectores</p>
	</li>
	<li>
	<p><code>dot()</code> — la multiplicación escalar de dos vectores</p>
	</li>
	<li>
	<p><code>cross()</code> — la multiplicación cruzada de dos vectores (solamente relevante en tres dimensiones)</p>
	</li>
	<li>
	<p><code>random2D()</code> - crea un vector 2D random</p>
	</li>
	<li>
	<p><code>random3D()</code> - crea un vector 3D random</p>
	</li>
</ul>

<p>Teniendo cubierta la adición, empecemos con la substracción. Esta no es tan difícil; ¡Simplemente toma el signo más y reemplázalo por un menos!</p>

<section data-type="sect2" id="_vector_subtraction">
<h2>Substracción de vectores</h2>

<a data-primary="PVector class (Processing)" data-secondary="sub() function" data-type="indexterm"></a> <a data-primary="sub() function (PVector class)" data-type="indexterm"></a>

<div data-type="equation">\vec{w} = \vec{u} - \vec{v}</div>

<p>puede escribirse como:</p>


<div class="narrow">
<div data-type="equation">w_x = u_x - v_x</div>
<div data-type="equation">w_y = u_y - v_y</div>
</div>

<figure id="chapter01_figure7"><img alt="Figure 1.7: Vector Subtraction" src="chapter01/ch01_07.png" />
<figcaption>Figura 1.7: Substracción de Vectores&nbsp;</figcaption>
</figure>

<p>entonces la función dentro de <code>PVector</code> se ve así:</p>

<pre data-code-language="java" data-type="programlisting" class="codesplit">
  void sub(PVector v) {
    x = x - v.x;
    y = y - v.y;
  }</pre>

<p>El siguiente ejemplo demuestra la substracción de vectores tomando la diferencia entre dos puntos—la ubicación del mouse y el centro de la ventana. Nota el uso de <code>translate </code> para visualizar el vector resultante como una línea desde el centro (width/2, height/2) hacia el mouse.</p>

<figure class="screenshot" data-pde="processingjs/chapter01/_1_3_vector_subtraction/_1_3_vector_subtraction.pde"><img alt="ch01 ex03" src="chapter01/ch01_ex03.png" />
<figcaption>&nbsp;</figcaption>
</figure>

<div data-type="example"><h5>Ejemplo 1.3: Substracción de Vectores</h5></div>

<pre data-code-language="java" data-type="programlisting" class="codesplit">
void setup() {
  size(640, 360);
}

void draw() {
  background(255);
  //Dos PVectors, uno para la ubicación del mouse y uno para el centro de la ventana
  PVector mouse  = new PVector(mouseX, mouseY);
  PVector centro = new PVector(width/2, height/2);

  //{!3} Dibuja los dos vectores originales
  stroke(200);
  line(0, 0, mouse.x, mouse.y);
  line(0, 0, centro.x, centro.y);

  // ¡Substracción de PVector!
  mouse.sub(centro);

  //{!3} Dibuja una línea para representar el vector.
  // Observa como muevo el origen con translate() para ubicar el vector
  stroke(0);
  translate(width/2, height/2);
  line(0, 0, mouse.x, mouse.y);
}</pre>

<a data-primary="vectors" data-secondary="commutative/associative rules of addition/subtraction with" data-type="indexterm"></a>
</section>

<section data-type="sect2" id="_vector_multiplication">
<h2>Multiplicación de vectores</h2>

<a data-primary="mult() function (PVector class)" data-type="indexterm"></a> <a data-primary="PVector class (Processing)" data-secondary="mult() function" data-type="indexterm"></a> <a data-primary="vectors" data-secondary="multiplying" data-type="indexterm"></a> <a data-primary="vectors" data-secondary="scaling" data-type="indexterm"></a>

<p>Tenemos que pensar de una manera un poco distinta para seguir con la multiplicación. Cuando hablamos de multiplicar un vector, lo que típicamente queremos es <strong><em>escalar</em></strong> un vector. Si quisiéramos escalar un vector al doble de su tamaño o a un tercio de su tamaño (dejando su dirección igual), diríamos: "Multiplica el vector por 2" ó "Multiplica el vector por 1/3." Nota que estamos multiplicando un vector por un escalar, un único número, no por otro vector.</p>

<p>Para escalar un vector, multiplicamos cada componente (<code>x</code> e <code>y</code>) por un escalar.</p>

<figure class="half-width-right" id="chapter01_figure8"><img alt="Figure 1.8: Scaling a vector" src="chapter01/ch01_08.png" />
<figcaption>Figura 1.8: Escalando un vector&nbsp;</figcaption>
</figure>

<div data-type="equation">\vec{w} = \vec{u} * n</div>

<p>puede escribirse como:</p>

<div class="narrow">
<div data-type="equation">w_x = u_x * n</div>
<div data-type="equation">w_y = u_y * n</div>
</div>

<p>Veamos un ejemplo con notación de vector.</p>

<div class="narrow">
<div data-type="equation">\vec{u} = (-3,7)</div>
<div data-type="equation">{n} = 3</div>
</div>

<div class="narrow">
<div data-type="equation">\vec{w} = \vec{u} * n</div>
<div data-type="equation">w_x = -3 * 3</div>
<div data-type="equation">w_y = 7 * 3</div>
</div>

<div data-type="equation">\vec{w} = (-9,21)</div>

<p>Por lo tanto, la función dentro de la clase <code>PVector</code> está escrita como:</p>

<pre data-code-language="java" data-type="programlisting" class="codesplit">
void mult(float n) {
   //{!2} Con la multiplicación, los componentes de un vector están multiplicados por un número.
   x = x * n;
   y = y * n;
 }</pre>

<p>E implementar la multiplicación en el código es tan simple como:</p>

<a data-primary="mult() function (PVector class)" data-secondary="implementation" data-type="indexterm"></a>

<pre data-code-language="java" data-type="programlisting" class="codesplit">
PVector u = new PVector(-3, 7);
// Este PVector ahora es tres veces su tamaño y equivale a (-9,21).
u.mult(3);</pre>

<figure class="screenshot" data-pde="processingjs/chapter01/_1_4_vector_multiplication/_1_4_vector_multiplication.pde"><img alt="ch01 ex04" src="chapter01/ch01_ex04.png" />
<figcaption>&nbsp;</figcaption>
</figure>

<div data-type="example"><h5>Ejemplo 1.4: Multiplicando un vector</h5></div>

<pre data-code-language="java" data-type="programlisting" class="codesplit">
void setup() {
  size(640, 360);
}

void draw() {
  background(255);

  PVector mouse = new PVector(mouseX, mouseY);
  PVector centro = new PVector(width/2, height/2);
  mouse.sub(centro);
  //{!1} ¡Multiplicando un vector! El vector ahora es la mitad de su tamaño original (multiplicado por 0.5).
  mouse.mult(0.5);
  translate(width/2, height/2);
  line(0, 0, mouse.x, mouse.y);

}</pre>

<figure class="half-width-right" id="chapter01_figure9"><img alt="Figure 1.9" src="chapter01/ch01_09.png" />
<figcaption>Figura 1.9</figcaption>
</figure>

<a data-primary="div() function (PVector class)" data-type="indexterm"></a> <a data-primary="PVector class (Processing)" data-secondary="div() function" data-type="indexterm"></a>

<p>La división funciona igual que la multiplicación — simplemente reemplazamos el signo de multiplicación (asterisco) por un signo de división (barra inclinada hacia la derecha).</p>

<pre data-code-language="java" data-type="programlisting" class="codesplit">
void div(float n) {
  x = x / n;
  y = y / n;
}

PVector u = new PVector(8, -4);
// ¡Dividiendo un vector! El vector ahora es la mitad de su tamaño original (dividido por 2).
u.div(2);</pre>

<a data-primary="vectors" data-secondary="associative/distributive rules for multiplication/division of" data-type="indexterm"></a>

<div data-type="note">
<h2>Más Propiedades de Números con Vectores</h2>

<p>Como sucede con la adición, las leyes algebraicas básicas de la multiplicación se aplican a los vectores.</p>

<p>La ley asociativa: <span data-type="equation">(n * m) * \vec{v} = n * (m * \vec{v})</span><br />
La ley distributiva con 2 escalar, 1 vector: <span data-type="equation">(n + m) * \vec{v} = (n * \vec{v}) + (m * \vec{v})</span><br />
La ley distributiva con 2 vectores, 1 escalar: <span data-type="equation">(\vec{u} + \vec{v}) * n = (\vec{u} * n) + (\vec{v} * n)
</span></p>
</div>
</section>
</section>

<section data-type="sect1" id="chapter01_section5">
<h2>1.5 Magnitud de Vectores</h2>

<a data-primary="magnitude (of vectors)" data-type="indexterm"></a> <a data-primary="vectors" data-secondary="magnitude" data-type="indexterm"></a>

<p>Multiplicación y división, como acabamos de ver, son métodos con los cuales la longitud del vector puede ser cambiada pero sin afectar su dirección. Quizás te estas preguntando: "Ok, entonces como se cual es la longitud del vector? Conozco los componentes (<code>x</code> e <code>y</code>), pero que tan larga (en pixeles) es actualmente la flecha?" Entender cómo calcular la longitud (también conocido como <strong><em>magnitud</em></strong>) de un vector es increíblemente útil e importante.
</p>

<figure class="half-width-right">
<img alt="Nature of Code Image" src="chapter01/ch01_10.png" />
<figcaption>
    Figure 1.10: La longitud o “magnitud” de un vector <svg:svg height="12.190371pt" viewbox="0 -9.600527 8.520000 12.190371" width="8.520000pt" xmlns="http://www.w3.org/1998/Math/MathML" xmlns:svg="http://www.w3.org/2000/svg" xmlns:svgmath="http://www.grigoriev.ru/svgmath"><svg:metadata><svgmath:metrics axis="6.57421875" baseline="2.58984375" bottom="2.44921875" top="12.1903710937"></svgmath:metrics></svg:metadata><svg:g transform="translate(1.596914, 0.000000)"><svg:text fill="black" font-family="Times New Roman" font-size="12.000000" font-style="italic" text-anchor="middle" x="2.663086" y="0.000000">v</svg:text></svg:g><svg:g transform="translate(0.000000, -8.785137)"><svg:text fill="black" font-family="Times New Roman" font-size="8.520000" text-anchor="middle" x="4.260000" y="2.828906">&rarr;</svg:text></svg:g></svg:svg> is often written as: <svg:svg height="12.503906pt" viewbox="0 -9.914062 29.061672 12.503906" width="29.061672pt" xmlns="http://www.w3.org/1998/Math/MathML" xmlns:svg="http://www.w3.org/2000/svg" xmlns:svgmath="http://www.grigoriev.ru/svgmath"><svg:metadata><svgmath:metrics axis="6.57421875" baseline="2.58984375" bottom="1.37109375" top="12.357421875"></svgmath:metrics></svg:metadata><svg:g transform="translate(0.000000, -3.984375)"><svg:text fill="black" font-family="Lucida Sans Unicode" font-size="12.000000" text-anchor="middle" x="3.468750" y="3.468750">∥</svg:text></svg:g><svg:g transform="translate(10.270836, 0.000000)"><svg:g transform="translate(1.596914, 0.000000)"><svg:text fill="black" font-family="Times New Roman" font-size="12.000000" font-style="italic" text-anchor="middle" x="2.663086" y="0.000000">v</svg:text></svg:g><svg:g transform="translate(0.000000, -8.785137)"><svg:text fill="black" font-family="Times New Roman" font-size="8.520000" text-anchor="middle" x="4.260000" y="2.828906">&rarr;</svg:text></svg:g></svg:g><svg:g transform="translate(22.124172, -3.984375)"><svg:text fill="black" font-family="Lucida Sans Unicode" font-size="12.000000" text-anchor="middle" x="3.468750" y="3.468750">∥</svg:text></svg:g></svg:svg>
</figcaption>
</figure>

<a data-primary="Pythagoras" data-type="indexterm"></a> <a data-primary="Pythagorean theorem" data-type="indexterm"></a>

<p>Notemos en el diagrama de arriba, como el vector, dibujado como una flecha y dos componentes (<code>x</code> e <code>y</code>), crean un triángulo rectángulo. Los lados son los componentes y la hipotenusa es la propia flecha. Somos muy afortunados de tener este triángulo rectángulo, porque una vez, un matemático griego llamado Pitágoras desarrolló una fórmula para describir la relación entre los lados y la hipotenusa del triángulo rectángulo.</p>

<figure class="half-width-right" id="chapter01_figure11"><img alt="Figure 1.11: The Pythagorean Theorem" src="chapter01/ch01_11.png" />
<figcaption>Figura 1.11: El Teorema de Pitágoras&nbsp;</figcaption>
</figure>

<p>El teorema de Pitágoras dice que en un triángulo rectángulo, <em>a</em> al cuadrado más <em>b</em> al cuadrado es igual a <em>c</em> al cuadrado.</p>

<p>Con esta fórmula, ahora podemos calcular la magnitud de <span data-type="equation">\vec{v}</span> de esta manera:</p>

<div data-type="equation">||\vec{v}||=\sqrt{v_x * v_x + v_y * v_y}</div>

<p>o en <code>PVector</code>:</p>

<pre data-code-language="java" data-type="programlisting" class="codesplit">
float mag() {
  return sqrt(x*x + y*y);
}</pre>

<figure class="screenshot" data-pde="processingjs/chapter01/_1_5_vector_magnitude/_1_5_vector_magnitude.pde"><img alt="ch01 ex05" src="chapter01/ch01_ex05.png" />
<figcaption>&nbsp;</figcaption>
</figure>

<div data-type="example"><h5>Ejemplo 1.5: Magnitud de un Vector</h5></div>

<a data-primary="mag() function (PVector class)" data-type="indexterm"></a> <a data-primary="PVector class (Processing)" data-secondary="mag() function" data-type="indexterm"></a>

<pre data-code-language="java" data-type="programlisting" class="codesplit">
void setup() {
  size(640, 360);
}

void draw() {
  background(255);

  PVector mouse = new PVector(mouseX, mouseY);
  PVector centro = new PVector(width/2, height/2);
  mouse.sub(centro);

  //{!3} La magnitud (es decir, longitud) de un vector puede ser accedida desde la función mag(). Acá la usamos para definir el ancho de un rectángulo dibujado en la parte superior de la ventana.
  float m = mouse.mag();
  fill(0);
  rect(0, 0, m, 10);

  translate(width/2, height/2);
  line(0, 0, mouse.x, mouse.y);

}</pre>
</section>

<section data-type="sect1" id="chapter01_section6">
<h2>1.6 Normalización de Vectores</h2>

<a data-primary="normalization" data-type="indexterm"></a> <a data-primary="unit vectors" data-type="indexterm"></a> <a data-primary="vectors" data-secondary="normalization" data-type="indexterm"></a> <a data-primary="vectors" data-secondary="unit vectors" data-type="indexterm"></a>

<p>Calcular al magnitud de un vector es sólo el comienzo. La función magnitud abre la puerta a muchas posibilidades, la primera es la <strong><em>normalización</em></strong>. La normalización se refiere al proceso de hacer algo "estándar", o bien "normal." En el caso de los vectores, supongamos por un momento que un vector estándar tiene una longitud de 1. Para normalizar un vector, por lo tanto, hay que tomar un vector de cualquier longitud y, manteniendo la dirección de este, cambiar su longitud a 1, convirtiéndolo en lo que se llama un <strong><em>vector unitario</em></strong> o <strong><em>versor</em></strong>.
</p>

<figure class="half-width-right" id="chapter01_figure12"><img alt="Figure 1.12" src="chapter01/ch01_12.png" />
<figcaption>Figure 1.12</figcaption>
</figure>

<p>Ya que describe la dirección del vector sin tomar en cuenta su longitud, es bastante útil tener el versor al alcance. Veremos como esto es útil cuando comencemos a trabajar con fuerzas en el capítulo 2.</p>

<p>Por cada vector <span data-type="equation">\vec{u}</span>
, su vector unitarios (escrito como <span data-type="equation">\hat{u}</span>) se calcula de esta manera:</p>

<div data-type="equation">\hat{u} = \frac{\vec{u}}{||\vec{u}||}</div>

<p>En otras palabras, para normalizar un vector, simplemente divide cada componente por su magnitud. Esto es bastante intuitivo. Digamos que la longitud del vector es 5. Entonces, 5 dividido por 5 es 1. Mirando a nuestro triángulo rectángulo, cuando tengamos que escalar la hipotenusa la dividiremos por 5. En este proceso los lados se encojen, divididos por 5 también.</p>

<a data-primary="normalize() function (PVector class)" data-type="indexterm"></a> <a data-primary="PVector class (Processing)" data-secondary="normalize() function" data-type="indexterm"></a>

<figure class="half-width-right" id="chapter01_figure13"><img alt="Figure 1.13" src="chapter01/ch01_13.png" />
<figcaption>Figure 1.13</figcaption>
</figure>

<p>En la clase <code>PVector</code>, escribimos nuestras funciones de normalización como lo siguiente:</p>

<pre data-code-language="java" data-type="programlisting" class="codesplit">
void normalize() {
  float m = mag();
  div(m);
}</pre>

<p>Por supuesto, hay un pequeño inconveniente. ¿Qué pasa si la magnitud del vector es 0? ¡No podemos dividir por 0! Un rápido corrector de errores solucionara esto:</p>

<pre data-code-language="java" data-type="programlisting" class="codesplit">
void normalize() {
 float m = mag();
 if (m != 0) {
   div(m);
 }
}</pre>

<figure class="screenshot" data-pde="processingjs/chapter01/_1_6_vector_normalize/_1_6_vector_normalize.pde"><img alt="ch01 ex06" src="chapter01/ch01_ex06.png" />
<figcaption>&nbsp;</figcaption>
</figure>

<div data-type="example"><h5>Example 1.6: Normalizing a vector</h5></div>

<pre data-code-language="java" data-type="programlisting" class="codesplit">
void draw() {
  background(255);

  PVector mouse = new PVector(mouseX, mouseY);
  PVector centro = new PVector(width/2, height/2);
  mouse.sub(centro);

  //{!2}En este ejemplo, luego que el vector es normalizado, es multiplicado por 50 para que sea visible en la pantalla. Notemos como sin importar dónde esté el mouse, el vector tendrá la misma longitud (50) debido a su proceso de normalización.
  mouse.normalize();
  mouse.mult(50);
  translate(width/2, height/2);
  line(0, 0, mouse.x, mouse.y);

}</pre>
</section>

<section data-type="sect1" id="chapter01_section7">
<h2>1.7 Movimiento y Vectores: Velocidad</h2>

<a data-primary="motion" data-type="indexterm"></a> <a data-primary="vectors" data-secondary="velocity and" data-type="indexterm"></a> <a data-primary="velocity" data-type="indexterm"></a>

<p>Todo esto sobre matemáticas vectoriales suena como algo que debiéramos saber, pero ¿por qué? ¿Cómo nos ayudará a escribir código? La verdad, es que debemos tener un poco de paciencia. Tomará algo de tiempo antes que la maravilla de usar <code>Pvector</code> aparezca en todo su esplendor. Esto, en realidad, es algo frecuente cuando aprendemos sobre nuevas estructuras de datos. Por ejemplo, cuando aprendes sobre arreglos pareciera que es mucho más trabajo usar <em>arrays</em> que un puñado de variables para guardar múltiples cosas. Pero eso cambia rápidamente cuando necesitas cientos o miles, o decenas de miles de cosas. Lo mismo ocurre cuando usas <code>Pvector</code>. Lo que parece más trabajo ahora, rendirá sus frutos más tarde, y de forma muy benenficiosa. Y no tienes que esperar mucho, porque el beneficio llegará en el próximo capítulo.</p>


<p>Por ahora, sin embargo, nos concentraremos en la simplicidad. ¿Qué significa programar movimiento usando vectores? Vimos el inicio de esto en el <a href="#chapter01_example2">Ejemplo 1.2</a><code>:</code> la pelota saltarina. Un objeo en la pantalla tiene una posición (dónde está en cualquier momento dado), como también una velocidad (instrucciones sobre cómo se debe mover de un momento al siguiente). La velocidad es sumada a la posición.</p>


<pre data-code-language="java" data-type="programlisting" class="codesplit">
posicion.add(velocidad);</pre>

<p>Y luego dibujamos el objeto en esa posición:</p>

<pre data-code-language="java" data-type="programlisting" class="codesplit">
ellipse(posicion.x,posicion.y,16,16);</pre>

<p>Esta es la base del movimiento: Movimiento 101</p>

<ol>
	<li>
	<p><strong><em>Agrega velocidad a la posición</em></strong></p>
	</li>
	<li>
	<p><strong><em>Dibuja el objeto en la posición</em></strong></p>
	</li>
</ol>

<a data-primary="Processing" data-secondary="OOP online tutorial" data-type="indexterm"></a>

<p>En la pelota saltarina, todo el código ocurre en la pestaña principal de Processing, dentro del bloque <code>setup()</code> y <code>draw()</code>. Lo que queremos ahora, es poder encapsular toda la lógica de movimiento en una <strong><em>clase</em></strong>. Así, podemos crear una base para programar objetos que se mueven en Processing. En la <a href="#intro_section2">sección I.2 de la Introducción</a>, "La Clase del Caminante Aleatorio", revisamos brevemente las bases de la programación orientada a objetos ("OOP"). Más allá de esa breve introducción, este libro asume experiencia con objetos y clases en Processing. Si necesitas un recordatorio, te sugiero revisar el <a href="http://processing.org/learning/objects/">tutorial de Objetos en Proessing</a>.</p>

<p>En este caso, crearemos una clase <code>Movedora</code> genérica que describirá una cosa que se mueve por la patnalla. Por lo que tenemos que considerar las siguientes dos preguntas:</p>

<ol>
	<li>
	<p><strong><em>¿Qué datos tiene un movedor?</em></strong></p>
	</li>
	<li>
	<p><strong><em>¿Qué funcionalidades tiene un movedor?</em></strong></p>
	</li>
</ol>

<p>Nuestro algoritmo Movimiento 101 responde esas preguntas. Un objeto <code>Movedor</code> tiene dos grupos de datos: <code>posicion</code> y <code>velocidad</code>, y ambos son objetos tipo <code>PVector</code>.</p>

<pre data-code-language="java" data-type="programlisting" class="codesplit">
class Movedor {

  PVector posicion;
  PVector velocidad;</pre>

<p>Su funcionalidad es igualmente simple. El <code>Movedor</code> se debe mover y se debe ver. Implementaremos estas necesidades como funciones llamadas <code>actualizar()</code> y <code>mostrar()</code>. Pondremos la løgica de movimiento dentro de <code>actualizar()</code> y dibujaremos el objeto en <code>mostrar()</code>.</p>

<pre data-code-language="java" data-type="programlisting" class="codesplit">
  void actualizar() {
    //{!1} El Movedor se mueve.
    posicion.add(velocidad);
  }

  void mostrar() {
    stroke(0);
    fill(175);
    //{!1} Ahora mostramos el Movedor.
    ellipse(posicion.x, posicion.y, 16, 16);
  }
}</pre>

<a data-primary="class (Processing)" data-secondary="constructor" data-type="indexterm"></a> <a data-primary="constructor" data-type="indexterm"></a>

<p>Hemos olvidado un elemento crucial: el <strong><em>constructor</em></strong></p>. El construcor es una función especial al interior de una clase que crea la instancia del objeto mismo. Es el lugar donde dejamos las instrucciones sobre cómo crear y configurar el objeto. Siempre tiene el mismo nombre que la clase, y se invoca utilizando el operador o palabra clave <strong><em>new</em></strong> (nuevo):</p>

<pre data-code-language="java" data-type="programlisting" class="codesplit">
  Movedor m = new Movedor();</pre>

<p>En nuestro caso, decidamos arbitrariamente inicializar nuestro objeto <code>Movedor</code> dándole una posición y velocidad aleatorias.</p>

<pre data-code-language="java" data-type="programlisting" class="codesplit">
  Movedor() {
    posicion = new PVector(random(width), random(height));
    velocidad = new PVector(random(-2,2), random(-2,2));
  }</pre>

<p>Si la programación orientada a objetos es algo nuevo para ti, un aspecto de esto puede ser confuso. Después de todo, iniciamos este capítulo discutiendo la clase <code>PVector</code>. La clase <code>PVector</code> es una plantilla para hacer un objeto de <code>posición</code> y otro de <code>velocidad</code>. Entonces ¿qué hacen dentro de otro objeto, dentro de la clase <code>Movedor</code>? En realidad, esto es algo muy normal. Un objeto es simplemente algo que contiene data (y funcionalidad). ¡Los datos pueden ser números (enteros, decimales, etc.) u otros objetos! Veremos esto una y otra vez en este libro. Pro ejemplo, en el <a href="#chapter04_section1">Capítulo 4</a> escribiremos una clase para describir un sistema de partículas. El objeto <code>SistemaDeParticulas</code> tendrá como datos, una lista de objetos tipo <code>Particula</code>… y cada <code>Particula</code> tiene como datos variados objetos tipo <code>Pvector</code>.</p>


<p>Terminemos de escribir la clase <code>Movedor</code> incorporándoles una función para determinar qué debe hacer el objeto cuando llegue al borde de la ventana. Por ahora, hagamos algo simple, y sólo programemos que pase de un borde al otro.</p>


<pre data-code-language="java" data-type="programlisting" class="codesplit">
  void revisaBordes() {
    //{!11} Cuando lega a un borde, configura la posición para el borde opuesto.
    if (posicion.x > width) {
      posicion.x = 0;
    } else if (posicion.x < 0) {
      posicion.x = width;
    }

    if (posicion.y > height) {
      posicion.y = 0;
    } else if (posicion.y < 0) {
      posicion.y = height;
    }
  }</pre>


<p>Ahora que la clase <code>Movedor</code> está terminada, podemos ver qué hacer en nuestro programa principal. Primero declaremos un nuevo  objeto basado en <code>Movedor</code>:</p>

<pre data-code-language="java" data-type="programlisting" class="codesplit">
Movedor movedor;</pre>

<p>Luego, crear e inicializar a movedor en el <code>setup()</code>:</p>

<pre data-code-language="java" data-type="programlisting" class="codesplit">
movedor = new Movedor();</pre>

<p>y llamar la función correspondiente en <code>draw()</code>:</p>

<pre data-code-language="java" data-type="programlisting" class="codesplit">
movedor.actualizar();
movedor.revisarBorde();
movedor.mostrar();</pre>

<p>Acá está el ejemplo completo para referencia:</p>

<figure class="screenshot" data-pde="processingjs/chapter01/_1_7_motion101/_1_7_motion101.pde processingjs/chapter01/_1_7_motion101/Mover.pde"><img alt="ch01 ex07" src="chapter01/ch01_ex07.png" />
<figcaption>&nbsp;</figcaption>
</figure>

<div data-type="example"><h5>Ejemplo 1.7: Movedor 101 (velocidad)</h5></div>

<pre data-code-language="java" data-type="programlisting" class="codesplit">
  //{!1} Declarar objeto Movedor
  Movedor movedor;

  void setup() {
    size(640, 360);
    //{!1} Crear objeto Movedor
    movedor = new Movedor();
  }
  void draw() {
    background(255);

    //{!3} Llamar las funciones del objeto Movedor
    movedor.actualizar();
    movedor.revisaBordes();
    movedor.mostrar();
  }

</pre>
<pre data-code-language="java" data-type="programlisting" class="codesplit">
  class Movedor {
    {!2} El objeto tiene dos PVectores: posicion y velocidad.
    PVector posicion;
    PVector velocidad;

    Movedor() {
      posicion = new PVector(random(width), random(height));
      velocidad = new PVector(random(-2, 2), random(-2, 2));
    }

    void actualizar() {
      //{!1} El Movedor se mueve por la velocidad
      posicion.add(velocidad);
    }

    void mostrar() {
      stroke(0);
      fill(175);
      //{!1} Ahora mostramos el Movedor.
      ellipse(posicion.x, posicion.y, 16, 16);
    }

    void revisaBordes() {
      //{!11} Cuando lega a un borde, configura la posición para el borde opuesto.
      if (posicion.x > width) {
        posicion.x = 0;
      } else if (posicion.x < 0) {
        posicion.x = width;
      }

      if (posicion.y > height) {
        posicion.y = 0;
      } else if (posicion.y < 0) {
        posicion.y = height;
      }
    }
  }</pre>
</section>

<section data-type="sect1" id="chapter01_section8">
<h2>1.8 Movimiento y Vectores: Aceleración</h2>

<a data-primary="acceleration" data-type="indexterm"></a> <a data-primary="vectors" data-secondary="acceleration" data-type="indexterm"></a> <a data-primary="velocity" data-secondary="acceleration" data-type="indexterm"></a>

<p>OK. At this point, we should feel comfortable with two things: (1) what a <code>PVector</code> is and (2) how we use <code>PVector</code><code>s</code> inside of an object to keep track of its position and movement. This is an excellent first step and deserves a mild round of applause. Before standing ovations and screaming fans, however, we need to make one more, somewhat bigger step forward. After all, watching the Motion 101 example is fairly boring—the circle never speeds up, never slows down, and never turns. For more interesting motion, for motion that appears in the real world around us, we need to add one more <code>PVector</code> to our class—<code>acceleration</code>.</p>

<p>The strict definition of <strong><em>acceleration</em></strong> we’re using here is: <em>the rate of change of velocity</em>. Let’s think about that definition for a moment. Is this a new concept? Not really. Velocity is defined as <em>the rate of change of position</em>. In essence, we are developing a “trickle-down” effect. Acceleration affects velocity, which in turn affects position (for some brief foreshadowing, this point will become even more crucial in the next chapter, when we see how forces affect acceleration, which affects velocity, which affects position). In code, this reads:</p>

<pre data-code-language="java" data-type="programlisting" class="codesplit">
velocity.add(acceleration);
position.add(velocity);</pre>

<p>As an exercise, from this point forward, let’s make a rule for ourselves. Let’s write every example in the rest of this book without ever touching the value of velocity and position (except to initialize them). In other words, our goal now for programming motion is: Come up with an algorithm for how we calculate acceleration and let the trickle-down effect work its magic. (In truth, you’ll find reasons to break this rule, but it’s important to illustrate the principles behind our motion algorithm.) And so we need to come up with some ways to calculate acceleration:</p>

<section data-type="sect2" id="_acceleration_algorithms">
<h3>Acceleration Algorithms!</h3>

<a data-primary="acceleration" data-secondary="algorithms for" data-type="indexterm"></a> <a data-primary="acceleration algorithms" data-type="indexterm"></a>

<ol>
	<li>
	<p><em>A constant acceleration</em></p>
	</li>
	<li>
	<p><em>A totally random acceleration</em></p>
	</li>
	<li>
	<p><em>Acceleration towards the mouse</em></p>
	</li>
</ol>

<a data-primary="acceleration algorithms" data-secondary="constant" data-type="indexterm"></a>

<p>Algorithm #1, <em>a constant acceleration</em>, is not particularly interesting, but it is the simplest and will help us begin incorporating acceleration into our code. The first thing we need to do is add another <code>PVector</code> to the <code>Mover</code> class:</p>

<pre data-code-language="java" data-type="programlisting" class="codesplit">
class Mover {

  PVector position;
  PVector velocity;
  //{.bold} A new PVector for acceleration
  PVector acceleration;</pre>

<p>And incorporate acceleration into the <code>update()</code> function:</p>

<pre data-code-language="java" data-type="programlisting" class="codesplit">
 void update() {
    //{!2 .bold} Our motion algorithm is now two lines of code!
    velocity.add(acceleration);
    position.add(velocity);
 }</pre>

<p>We’re almost done. The only missing piece is initialization in the constructor.</p>

<pre data-code-language="java" data-type="programlisting" class="codesplit">
  Mover() {</pre>

<p>Let’s start the <code>Mover</code> object in the middle of the window…</p>

<pre data-code-language="java" data-type="programlisting" class="codesplit">
    position = new PVector(width/2,height/2);</pre>

<p>…with an initial velocity of zero.</p>

<pre data-code-language="java" data-type="programlisting" class="codesplit">
    velocity = new PVector(0,0);</pre>

<p>This means that when the sketch starts, the object is at rest. We don’t have to worry about velocity anymore, as we are controlling the object’s motion entirely with acceleration. Speaking of which, according to Algorithm #1, our first sketch involves constant acceleration. So let’s pick a value.</p>

<pre data-code-language="java" data-type="programlisting" class="codesplit">
    acceleration = new PVector(-0.001, 0.01);
  }</pre>

<p>Maybe you’re thinking, “Gosh, those values seem awfully small!” That’s right, they are quite tiny. It’s important to realize that our acceleration values (measured in pixels) accumulate over time in the velocity, about thirty times per second depending on our sketch’s frame rate. And so to keep the magnitude of the velocity vector within a reasonable range, our acceleration values should remain quite small. We can also help this cause by incorporating the <code>PVector</code> function <code>limit()</code>.</p>

<a data-primary="limit() function (PVector class)" data-type="indexterm"></a> <a data-primary="magnitude (of vectors)" data-secondary="limiting" data-type="indexterm"></a> <a data-primary="PVector class (Processing)" data-secondary="limit() function" data-type="indexterm"></a> <a data-primary="velocity" data-secondary="limiting" data-type="indexterm"></a>

<pre data-code-language="java" data-type="programlisting" class="codesplit">
// The limit() function constrains the magnitude of a vector.
velocity.limit(10);</pre>

<p>This translates to the following:</p>

<p><em>What is the magnitude of velocity? If it’s less than 10, no worries; just leave it as is. If it’s more than 10, however, reduce it to 10!</em></p>

<div data-type="exercise" id="chapter01_exercise4">
<h5>Exercise 1.4</h5>

<p>Write the <code>limit()</code> function for the <code>PVector</code> class.</p>

<pre data-code-language="java" data-type="programlisting" class="codesplit">
  void limit(float max) {
    if (_______ &gt; _______) {
      _________();
      ____(max);
    }
  }</pre>
</div>

<p>Let’s take a look at the changes to the <code>Mover</code> class, complete with <code>acceleration</code> and <code>limit()</code>.</p>

<figure class="screenshot" data-pde="processingjs/chapter01/_1_8_motion101_acceleration/_1_8_motion101_acceleration.pde processingjs/chapter01/_1_8_motion101_acceleration/Mover.pde"><img alt="ch01 ex08" src="chapter01/ch01_ex08.png" />
<figcaption>&nbsp;</figcaption>
</figure>

<div data-type="example"><h5>Example 1.8: Motion 101 (velocity and constant acceleration)</h5></div>

<pre data-code-language="java" data-type="programlisting" class="codesplit">
class Mover {

  PVector position;
  PVector velocity;
  // Acceleration is the key!
  PVector acceleration;

  //{!1} The variable topspeed will limit the magnitude of velocity.
  float topspeed;

  Mover() {
    position = new PVector(width/2, height/2);
    velocity = new PVector(0, 0);
    acceleration = new PVector(-0.001, 0.01);
    topspeed = 10;
  }

  void update() {
    //{!2} Velocity changes by acceleration and is limited by topspeed.
    velocity.add(acceleration);
    velocity.limit(topspeed);
    position.add(velocity);
  }

  // display() is the same.
  void display() {}

  //{!1} checkEdges() is the same.
  void checkEdges() {}
}</pre>

<div data-type="exercise" id="chapter01_exercise5">
<h5>Exercise 1.5</h5>

<p>Create a simulation of a car (or runner) that accelerates when you press the up key and brakes when you press the down key.</p>
</div>

<a data-primary="acceleration algorithms" data-secondary="random" data-type="indexterm"></a>

<p>Now on to Algorithm #2, <em>a totally random acceleration</em>. In this case, instead of initializing acceleration in the object’s constructor, we want to pick a new acceleration each cycle, i.e. each time <code>update()</code> is called.</p>

<figure class="screenshot" data-pde="processingjs/chapter01/_1_9_motion101_acceleration/_1_9_motion101_acceleration.pde processingjs/chapter01/_1_9_motion101_acceleration/Mover.pde"><img alt="ch01 ex09" src="chapter01/ch01_ex09.png" />
<figcaption>&nbsp;</figcaption>
</figure>

<div data-type="example"><h5>Example 1.9: Motion 101 (velocity and random acceleration)</h5></div>

<pre data-code-language="java" data-type="programlisting" class="codesplit">
  void update() {

    //{!1} The random2D() function will give us a PVector of length 1 pointing in a random direction.
    acceleration = PVector.random2D();

    velocity.add(acceleration);
    velocity.limit(topspeed);
    position.add(velocity);
  }</pre>

<p>Because the random vector is a normalized one, we can try scaling it:</p>

<p>(a) scaling the acceleration to a constant value</p>

<pre data-code-language="java" data-type="programlisting" class="codesplit">
acceleration = PVector.random2D();
//{.bold} Constant
acceleration.mult(0.5);</pre>

<p>(b) scaling the acceleration to a random value</p>

<pre data-code-language="java" data-type="programlisting" class="codesplit">
acceleration = PVector.random2D();
//{.bold} Random
acceleration.mult(random(2));</pre>

<p>While this may seem like an obvious point, it’s crucial to understand that acceleration does not merely refer to the <em>speeding up</em> or <em>slowing down</em> of a moving object, but rather <em>any change</em> in velocity in either magnitude or direction. Acceleration is used to steer an object, and we’ll see this again and again in future chapters as we begin to program objects that make decisions about how to move about the screen.</p>

<div data-type="exercise" id="chapter01_exercise6">
<h5>Exercise 1.6</h5>

<p>Referring back to the <a href="#intro_section6">Introduction</a>, implement acceleration according to Perlin noise.</p>
</div>
</section>
</section>

<section data-type="sect1" id="chapter01_section9">
<h2>1.9 Static vs. Non-Static Functions</h2>

<a data-primary="functions" data-secondary="static vs. non-static" data-type="indexterm"></a> <a data-primary="methods" data-secondary="static vs. non-static" data-type="indexterm"></a> <a data-primary="Processing" data-secondary="static vs. non-static methods" data-type="indexterm"></a>

<p>Before we get to Algorithm #3 (<em>accelerate towards the mouse</em>), we need to cover one more rather important aspect of working with vectors and the <code>PVector</code> class: the difference between using <strong><em>static</em></strong> methods and <strong><em>non-static</em></strong> methods.</p>

<p>Forgetting about vectors for a moment, take a look at the following code:</p>

<pre data-code-language="java" data-type="programlisting" class="codesplit">
float x = 0;
float y = 5;

x = x + y;</pre>

<p>Pretty simple, right? <code>x</code> has the value of 0, we add <code>y</code> to it, and now <code>x</code> is equal to 5. We could write the corresponding code pretty easily based on what we’ve learned about <code>PVector</code>.</p>

<pre data-code-language="java" data-type="programlisting" class="codesplit">
PVector v = new PVector(0, 0);
PVector u = new PVector(4, 5);
v.add(u);</pre>

<p>The vector <code>v</code> has the value of (0,0), we add <code>u</code> to it, and now <code>v</code> is equal to (4,5). Easy, right?</p>

<p>Let’s take a look at another example of some simple floating point math:</p>

<pre data-code-language="java" data-type="programlisting" class="codesplit">
float x = 0;
float y = 5;

float z = x + y;</pre>

<p><code>x</code> has the value of 0, we add <code>y</code> to it, and store the result in a new variable <code>z</code>. The value of <code>x</code> does not change in this example (neither does <code>y</code>)! This may seem like a trivial point, and one that is quite intuitive when it comes to mathematical operations with floats. However, it’s not so obvious with mathematical operations in <code>PVector</code>. Let’s try to write the code based on what we know so far.</p>

<pre data-code-language="java" data-type="programlisting" class="codesplit">
PVector v = new PVector(0,0);
PVector u = new PVector(4,5);
//{.line-through} Don’t be fooled; this is incorrect!!!
PVector w = v.add(u);</pre>

<p>The above might seem like a good guess, but it’s just not the way the <code>PVector</code> class works. If we look at the definition of <code>add()</code> . . .</p>

<pre data-code-language="java" data-type="programlisting" class="codesplit">
void add(PVector v) {
  x = x + v.x;
  y = y + v.y;
}</pre>

<p>we see that this code does not accomplish our goal. First, it does not return a new <code>PVector</code> (the return type is “void”) and second, it changes the value of the <code>PVector</code> upon which it is called. In order to add two <code>PVector</code> objects together and return the result as a new <code>PVector</code>, we must use the static <code>add()</code> function.</p>

<a data-primary="static functions" data-type="indexterm"></a>

<p>Functions that we call from the class name itself (rather than from a speciﬁc object instance) are known as <strong><em>static functions</em></strong>. Here are two examples of function calls that assume two <code>PVector</code> objects, <code>v</code> and <code>u</code>:</p>

<pre data-code-language="java" data-type="programlisting" class="codesplit">
// Static: called from the class name.
PVector.add(v, u);

// Not static: called from an object instance.
v.add(u);</pre>

<p>Since you can’t write static functions yourself in Processing, you might not have encountered them before. <code>PVector</code>'s static functions allow us to perform generic mathematical operations on <code>PVector</code> objects without having to adjust the value of one of the input <code>PVector</code><code>s</code>. Let’s look at how we might write the static version of <code>add()</code>:</p>

<pre data-code-language="java" data-type="programlisting" class="codesplit">
  //{!1} The static version of add allows us to add two PVectors together and assign the result to a new PVector while leaving the original PVectors (v and u above) intact.
  static PVector add(PVector v1, PVector v2) {
    PVector v3 = new PVector(v1.x + v2.x, v1.y + v2.y);
    return v3;
  }</pre>

<p>There are several differences here:</p>

<ul>
	<li>
	<p>The function is labeled as <strong><em>static</em></strong>.</p>
	</li>
	<li>
	<p>The function does not have a <strong><em>void</em></strong> return type, but rather returns a <code>PVector</code>.</p>
	</li>
	<li>
	<p>The function creates a new <code>PVector</code> (<code>v3</code>) and returns the sum of the components of <code>v1</code> and <code>v2</code> in that new <code>PVector</code>.</p>
	</li>
</ul>

<p>When you call a static function, instead of referencing an actual object instance, you simply reference the name of the class itself.</p>

<pre data-code-language="java" data-type="programlisting" class="codesplit">
PVector v = new PVector(0, 0);
PVector u = new PVector(4, 5);
//{.line-through .no-comment}
PVector w = v.add(u);
//{.bold .no-comment}
PVector w = PVector.add(v, u);</pre>

<p>The <code>PVector</code> class has static versions of <code>add()</code>, <code>sub()</code>, <code>mult()</code>, and <code>div()</code>.</p>

<div data-type="exercise" id="chapter01_exercise7">
<h5>Exercise 1.7</h5>

<p>Translate the following pseudocode to code using static or non-static functions where appropriate.</p>

<ul>
	<li>
	<p>The <code>PVector</code> <code>v</code> equals (1,5).</p>
	</li>
	<li>
	<p>The <code>PVector</code> <code>u</code> equals <code>v</code> multiplied by 2.</p>
	</li>
	<li>
	<p>The <code>PVector</code> <code>w</code> equals <code>v</code> minus <code>u</code>.</p>
	</li>
	<li>
	<p>Divide the <code>PVector</code> w by 3.</p>
	</li>
</ul>

<pre data-code-language="java" data-type="programlisting" class="codesplit">
PVector v = new PVector(1, 5);
PVector u = ________._____(__,__);
PVector w = ________._____(__,__);
___________;</pre>
</div>
</section>

<section data-type="sect1" id="chapter01_section10">
<h2>1.10 Interactivity with Acceleration</h2>

<a data-primary="acceleration algorithms" data-secondary="interactive" data-type="indexterm"></a>

<figure class="half-width-right" id="chapter01_figure14"><img alt="Figure 1.14" src="chapter01/ch01_14.png" />
<figcaption>Figure 1.14</figcaption>
</figure>

<p>To finish out this chapter, let’s try something a bit more complex and a great deal more useful. We’ll dynamically calculate an object’s acceleration according to a rule stated in Algorithm #3 — <em>the object accelerates towards the mouse</em>.</p>

<p>Anytime we want to calculate a vector based on a rule or a formula, we need to compute two things: <strong><em>magnitude</em></strong> and <strong><em>direction</em></strong>. Let’s start with direction. We know the acceleration vector should point from the object’s position towards the mouse position. Let’s say the object is located at the point (<code>x</code>,<code>y</code>) and the mouse at (<code>mouseX</code>,<code>mouseY</code>).</p>

<figure class="half-width-right" id="chapter01_figure15"><img alt="Figure 1.15" src="chapter01/ch01_15.png" />
<figcaption>Figure 1.15</figcaption>
</figure>

<p>In Figure 1.15, we see that we can get a vector (<code>dx</code>,<code>dy</code>) by subtracting the object’s position from the mouse’s position.</p>

<ul>
	<li>
	<p><span class="formula">dx = mouseX - x</span></p>
	</li>
	<li>
	<p><span class="formula">dy = mouseY - y</span></p>
	</li>
</ul>

<p>Let’s rewrite the above using <code>PVector</code> syntax. Assuming we are in the <code>Mover</code> class and thus have access to the object’s <code>PVector position</code>, we then have:</p>

<pre data-code-language="java" data-type="programlisting" class="codesplit">
PVector mouse = new PVector(mouseX,mouseY);
// Look! We’re using the static reference to sub() because we want a new PVector pointing from one point to another.
PVector dir = PVector.sub(mouse, position);</pre>

<p>We now have a <code>PVector</code> that points from the mover’s position all the way to the mouse. If the object were to actually accelerate using that vector, it would appear instantaneously at the mouse position. This does not make for good animation, of course, and what we want to do now is decide how quickly that object should accelerate toward the mouse.</p>

<p>In order to set the magnitude (whatever it may be) of our acceleration <code>PVector</code>, we must first <em>_</em> that direction vector. That’s right, you said it. <em>Normalize</em>. If we can shrink the vector down to its unit vector (of length one) then we have a vector that tells us the direction and can easily be scaled to any value. One multiplied by anything equals anything.</p>

<pre data-code-language="java" data-type="programlisting" class="codesplit">
float anything = ?????
dir.normalize();
dir.mult(anything);</pre>

<p>To summarize, we take the following steps:</p>

<ol>
	<li>
	<p>Calculate a vector that points from the object to the target position (mouse)</p>
	</li>
	<li>
	<p>Normalize that vector (reducing its length to 1)</p>
	</li>
	<li>
	<p>Scale that vector to an appropriate value (by multiplying it by some value)</p>
	</li>
	<li>
	<p>Assign that vector to acceleration</p>
	</li>
</ol>

<p>And here are those steps in the <code>update()</code> function itself:</p>

<figure class="screenshot" data-pde="processingjs/chapter01/_1_10_motion101_acceleration/_1_10_motion101_acceleration.pde processingjs/chapter01/_1_10_motion101_acceleration/Mover.pde"><img alt="ch01 ex10" src="chapter01/ch01_ex10.png" />
<figcaption>&nbsp;</figcaption>
</figure>

<div data-type="example"><h5>Example 1.10: Accelerating towards the mouse</h5></div>

<pre data-code-language="java" data-type="programlisting" class="codesplit">
 void update() {

    PVector mouse = new PVector(mouseX, mouseY);
    // Step 1: Compute direction
    PVector dir = PVector.sub(mouse, position);

    // Step 2: Normalize
    dir.normalize();

    // Step 3: Scale
    dir.mult(0.5);

    //{!1} Step 4: Accelerate
    acceleration = dir;

    velocity.add(acceleration);
    velocity.limit(topspeed);
    position.add(velocity);

  }</pre>

<p>You may be wondering why the circle doesn’t stop when it reaches the target. It’s important to note that the object moving has no knowledge about trying to stop at a destination; it only knows where the destination is and tries to go there as quickly as possible. Going as quickly as possible means it will inevitably overshoot the position and have to turn around, again going as quickly as possible towards the destination, overshooting it again, and so on and so forth. Stay tuned; in later chapters we’ll learn how to program an object to <strong><em>arrive</em></strong> at a position (slow down on approach).</p>

<p>This example is remarkably close to the concept of gravitational attraction (in which the object is attracted to the mouse position). Gravitational attraction will be covered in more detail in the next chapter. However, one thing missing here is that the strength of gravity (magnitude of acceleration) is inversely proportional to distance. This means that the closer the object is to the mouse, the faster it accelerates.</p>

<div data-type="exercise" id="chapter01_exercise8">
<h5>Exercise 1.8</h5>

<p>Try implementing the above example with a variable magnitude of acceleration, stronger when it is either closer or farther away.</p>
</div>

<p>Let’s see what this example would look like with an array of movers (rather than just one).</p>

<figure class="screenshot" data-pde="processingjs/chapter01/_1_11_motion101_acceleration_array/_1_11_motion101_acceleration_array.pde processingjs/chapter01/_1_11_motion101_acceleration_array/Mover.pde"><img alt="ch01 ex11" src="chapter01/ch01_ex11.png" />
<figcaption>&nbsp;</figcaption>
</figure>

<div data-type="example"><h5>Example 1.11: Array of movers accelerating towards the mouse</h5></div>

<pre data-code-language="java" data-type="programlisting" class="codesplit">
//{!1} An array of objects
Mover[] movers = new Mover[20];

void setup() {
  size(640, 360);
  background(255);
  for (int i = 0; i &lt; movers.length; i++) {
    //{!1} Initialize each object in the array.
    movers[i] = new Mover();
  }
}

void draw() {
  background(255);

  for (int i = 0; i &lt; movers.length; i++) {
    //{!3} Calling functions on all the objects in the array
    movers[i].update();
    movers[i].checkEdges();
    movers[i].display();
  }
}</pre>
<pre data-code-language="java" data-type="programlisting" class="codesplit">
class Mover {

  PVector position;
  PVector velocity;
  PVector acceleration;
  float topspeed;

  Mover() {
    position = new PVector(random(width), random(height));
    velocity = new PVector(0, 0);
    topspeed = 4;
  }

  void update() {

    //{.comment-header} Our algorithm for calculating acceleration:

    //{!2} Find the vector pointing towards the mouse.
    PVector mouse = new PVector(mouseX, mouseY);
    PVector dir = PVector.sub(mouse, position);


    // Normalize.
    dir.normalize();
    // Scale.
    dir.mult(0.5);
    // Set to acceleration.
    acceleration = dir;

    //{!3} Motion 101! Velocity changes by acceleration.  position changes by velocity.
    velocity.add(acceleration);
    velocity.limit(topspeed);
    position.add(velocity);
    }

  // Display the Mover
  void display() {
    stroke(0);
    fill(175);
    ellipse(position.x,position.y,16,16);
  }

  //{!13} What to do at the edges
  void checkEdges() {
    if (position.x &gt; width) {
      position.x = 0;
    } else if (position.x &lt; 0) {
      position.x = width;
    }

    if (position.y &gt; height) {
      position.y = 0;
    }  else if (position.y &lt; 0) {
      position.y = height;
    }
  }
}</pre>

<figure class="screenshot" id="chapter01_figure16"><img src="chapter01/ch01_16.png" />
<figcaption>Figure 1.16: The Ecosystem Project</figcaption>
</figure>

<div data-type="tip">
<h2>The Ecosystem Project</h2>

<p><em>As mentioned in the preface, one way to use this book is to build a single project over the course of reading it, incorporating elements from each chapter one step at a time. We’ll follow the development of an example project throughout this book—a simulation of an ecosystem. Imagine a population of computational creatures swimming around a digital pond, interacting with each other according to various rules.</em></p>

<p>Step 1 Exercise:</p>

<p>Develop a set of rules for simulating the real-world behavior of a creature, such as a nervous fly, swimming fish, hopping bunny, slithering snake, etc. Can you control the object’s motion by only manipulating the acceleration? Try to give the creature a personality through its behavior (rather than through its visual design).</p>
</div>
</section>
</section>
