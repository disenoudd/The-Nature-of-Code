<section data-type="Capítulo" id="_Capítulo_3_oscillation">
<h1>Capítulo 3. Oscilación</h1>

<blockquote data-type="epigraph">
<p>"La trigonometría es el seno de los tiempos.”</p>

<p data-type="attribution">— Anónimo</p>
</blockquote>

<p>En los capítulos 1 y 2, desarrollamos con detalle una estructura de programación orientada a objetos para mover elementos por la pantalla, utilizando el concepto de vector para representar posición, velocidad y aceleración, empujados por fuerzas en el ambiente. Podríamos continuar directamente con temas como sistemas de partículas, fuerzas conductoras, comportamientos grupales, etc. Si hiciéramos eso sin embargo, nos estaríamos saltando un área importante de las matemáticas que vamos a necesitar: <strong><em>trigonometría</em></strong>, o las matemáticas de los triángulos, especialmente del triángulo rectángulo.</p>

<p>La Trigonometría nos entrega muchas herramientas. Deberemos pensar en ángulos, velocidad angular y aceleración. La trigonometría nos enseñara acerca de las funciones seno y coseno, las que al ser usadas correctamente entregan agradables patrones de inicio y final de movimientos. Podremos calcular algunas fuerzas más complejas que involucran el vaivén de un péndulo, o de una caja que se desliza por un plano inclinado.</p>

<p>Este capítulo será entonces una mezcla de un poco de todo. Comenzaremos con lo básico sobre ángulos en Processing, y cubriremos variados apsectos trigonométricos, uniéndolo todo en las fuerzas, hacia el final. Y al dedicarle tiempo ahora, también pavimentaremos nuestro camino para los ejemplos más avanzados que desarrollaremos y que requerirán trigonometría.</p>

<section data-type="sect1" id="Capitulo03_section1">
<h2>3.1 Ángulos</h2>

<a data-primary="angles" data-type="indexterm"></a>

<p>OK. Antes de hacer nada, asegurémonos de comprender qué significa ser un ángulo en Processing. Si tienes experiencia con Processing, de seguro ya te topaste con problemas al utilizar la función <code>rotate()</code> para girar objetos.</p>

<a data-primary="angles" data-secondary="measuring in degrees" data-type="indexterm"></a> <a data-primary="degrees" data-type="indexterm"></a>

<p>Lo primero que debemos repasar es <strong><em>radianes</em></strong> y <strong><em>grados</em></strong>. Probablemente te sea más familiar el concepto de ángulos y su medición en <strong><em>grados</em></strong>. Una rotación completa va desde 0 a 360 grados. 90 grados (un ángulo recto) es 1/4 de 360, y se muestra abajo como dos líneas perpendiculares.</p>

<figure id="Capitulo03_figure1"><img alt="Figure 3.1" src="capitulo03/ch03_01.png" />
<figcaption>Figura 3.1</figcaption>
</figure>

<p>Es bastante intuitivo pensar en ángulos en términos de los grados. Por ejemplo, el cuadrado de la Figura 3.2 está rotado en 45 grados sobre su centro.</p>

<figure id="Capitulo03_figure2"><img alt="Figure 3.2" src="capitulo03/ch03_02.png" />
<figcaption>Figura 3.2</figcaption>
</figure>

<a data-primary="angles" data-secondary="measuring in radians" data-type="indexterm"></a> <a data-primary="Processing" data-secondary="angles" data-tertiary="measuring in" data-type="indexterm"></a> <a data-primary="radians" data-type="indexterm"></a>

<p>Processing sin embargo, requiere que los ángulos sean especificados en <strong><em>radianes</em></strong>. Radian es la unidad de medición para ángulos definido por la proporción entre el largo de un arco, y el radio del círculo que lo define. Un radian es el ángulo en el cual esa proporción equivale a uno. 180 grados = PI radianes, 360 grados = 2*PI radianes, 90 grados = PI/2 radianes, etc.</p>

<figure id="Capitulo03_figure3"><img alt="Figure 3.3" src="capitulo03/ch03_03.png" />
<figcaption>Figura 3.3</figcaption>
</figure>

<a data-primary="degrees" data-secondary="radians" data-tertiary="converting to" data-type="indexterm"></a> <a data-primary="radians" data-secondary="converting from degrees" data-type="indexterm"></a>

<p>La fórmula para convertir grados en radianes es:</p>

<p>radianes = 2 * PI * (grados / 360)</p>

<a data-primary="Processing" data-secondary="radians() function" data-type="indexterm"></a> <a data-primary="radians() function (Processing)" data-type="indexterm"></a>

<p>Afortunadamente, si preferimos pensar en grados pero programar con radianes, Processing nos facilita el trabajo. La función <code>radians()</code> convierte automáticamente valores desde grados a radianes, y las constantes <code>PI</code> y <code>TWO_PI</code> (Dos PI) nos dan acceso rápido a estos números utilizados frecuentemente (equivalentes a 180 y 360 grados, respectivamente). El siguiente código, por ejemplo, sirve para rotar figuras en 60 grados.</p>

<pre data-code-language="java" data-type="programlisting" class="codesplit">
float angulo = radians(60);
rotate(angulo);</pre>

<a data-primary="Processing" data-secondary="rotation tutorial" data-type="indexterm"></a>

<p>Si no estás familiarizado con cómo se implementa la rotación en Processing, sugiero revises este turorial: <a href="http://www.processing.org/learning/transform2d/">Processing — Transformaciones 2D</a>.</p>

<a data-primary="pi (π)" data-type="indexterm"></a> <a data-primary="PI variable (Processing)" data-type="indexterm"></a>

<div data-type="note">
<h2>Qué es PI?</h2>

<p>La constante matemática pi (o &pi;) es un número real definido como la proporción de la circumferencia de un círculo (distancia alrededor del perímetro) con su diámetro (una línea recta que pasa por el centro del círculo). Equivale aproximadamente a 3.14159 y puede ser obtenida en Processing con la variable incluida <code>PI</code>.</p>
</div>

<div data-type="exercise" id="Capitulo03_exercise1">
<h5>Ejercicio 3.1</h5>

<p>Rotar un objeto como un bastón, alrededor de su centro, utilizando <code>translate()</code> y <code>rotate()</code>.</p>

<figure class="screenshot" data-pde="processingjs/Chapter03/Ex_3_01_exercise_baton/Ex_3_01_exercise_baton.pde"><img alt="ch03 exc01" src="capitulo03/ch03_exc01.png" />
<figcaption>&nbsp;</figcaption>
</figure>
</div>
</section>

<section data-type="sect1" id="Capitulo03_section2">
<h2>3.2 Movimiento Angular</h2>

<a data-primary="acceleration" data-secondary="rotation" data-type="indexterm"></a> <a data-primary="angles" data-secondary="motion" data-type="indexterm"></a> <a data-primary="motion" data-secondary="angular" data-type="indexterm"></a> <a data-primary="rotation" data-type="indexterm"></a> <a data-primary="shapes" data-secondary="rotating" data-type="indexterm"></a>

<p>¿Recuerdas todo esto?</p>

<p><span class="fórmula">velocidad = velocidad + aceleración</span><br />
<span class="fórmula">posición = posición + velocidad</span></p>

<p>¿Recuerdas que le dedicamos casi todo los capítulos 1 y 2 a eso? Bien, podemos aplicar casi la misma lógica a un objeto que rota.</p>

<p><span class="fórmula">velocidad angular = velocidad angular + aceleración</span><br />
<span class="fórmula">ángulo = ángulo + velocidad angular</span></p>

<p>¡De hecho esto es incluso más simple que lo que ya vimos, pues un ángulo es una cantidad <em>escalar</em>, es decir un número, y no un vector!</p>

<p>Usando la respuesta el Ejercicio 3.1, digamos que queremos rotar un bastón en Processing en cierto ángulo. Tendríamos código como este:</p>

<pre data-code-language="java" data-type="programlisting" class="codesplit">
translate(width/2, height/2);
rotate(angulo);
line(-50, 0, 50, 0);
ellipse(50, 0, 8, 8);
ellipse(-50, 0, 8, 8);</pre>

<p>Si incorporamos nuestro principio de movimiento, tenemos lo siguiente.</p>

<figure class="screenshot" data-pde="processingjs/Chapter03/_3_01_angular_motion/_3_01_angular_motion.pde"><img alt="ch03 ex01" src="capitulo03/ch03_ex01.png" />
<figcaption>&nbsp;</figcaption>
</figure>

<div data-type="example"><h5>Ejemplo 3.1: Movimiento Angular utilizando rotate()</h5></div>

<pre data-code-language="java" data-type="programlisting" class="codesplit">
  // Posición
  float angulo = 0;

  // Velocidad
  float  velAngular = 0;

  // {!1} Aceleración
  float acelAngular = 0.001;

  void setup() {
    size(640, 360);
  }

  void draw() {
    background(255);

    fill(175);
    stroke(0);
    rectMode(CENTER);
    translate(width/2, height/2);
    rotate(angulo);
    line(-50, 0, 50, 0);
    ellipse(50, 0, 8, 8);
    ellipse(-50, 0, 8, 8);

    // Equivalente angular de velocidad.add(aceleracion);
    velAngular += acelAngular;
    // {!1} Equivalente angular de posicion.add(velocidad);
    angulo+= velAngular;
  }
</pre>

<p>El bastón comienza en la pantalla sin rotación, y luego gira más y más rápido en la medida que el ángulo de rotación acelera.</p>

<p>Esta idea podemos incporarla en nuestro objeto <code>caminante</code>. Por ejemplo, podemos agregar variables relacionadas con movimiento angular a nuestro <code>caminante</code>.</p>

<pre data-code-language="java" data-type="programlisting" class="codesplit">
  class Caminante {
    PVector posicion;
    PVector velocidad;
    PVector aceleracion;
    float masa;

    float angulo = 0;
    float velAngular = 0;
    float acelAngular = 0;
  }</pre>

<p>Y luego en <code>actualizar()</code>, actualizarmos tanto la posición como el ángulo ¡con el mismo algoritmo!</p>

<pre data-code-language="java" data-type="programlisting" class="codesplit">
  void actualizar() {
    //{!2} Fórmula clásica para movimiento
    velocidad.add(aceleracion);
    posicion.add(velocidad);

    //{!2} Nueva fórmula de movimiento angular
    velAngular += acelAngular;
    angulo += velAngular;

    aceleracion.mult(0);
  }</pre>

<p>Por supuesto, para que esto tenga relevancia, tenemos que rotar el objeto cuando lo mostramos.</p>

<pre data-code-language="java" data-type="programlisting" class="codesplit">
  void mostrar() {
    stroke(0);
    fill(175,200);
    rectMode(CENTER);
    //{!1} pushMatrix() y popMatrix() son necesarios para que la rotación no afecte a todo nuestro mundo.
    pushMatrix();

    // Fija el origen, en la posición del objeto.
    translate(posicion.x, posicion.y);
    //{!1} Rota según ángulo.
    rotate(angulo);
    rect(0, 0, masa * 16, masa * 16);
    popMatrix();
  }</pre>

<p>Ahora, si ejecutamos este código, no veremos nada nuevo. Esto es porque la aceleración angular (<code>float acelAngular = 0;</code>) fue inicializado en cero. Para que un objeto rote, ¡tenemos que darle aceleración! Por cierto, podemos darle un valor manualmente.</p>

<pre data-code-language="java" data-type="programlisting" class="codesplit">
float acelAngular = 0.01;</pre>

<p>Sin embargo, podemos tener resultados más interesantes asignando dinámicamente la aceleración angular según las fuerzas presentes en el ambiente. Podríamos eventualmente abrir la caja de pandora, intentando modelar la física de la aceleración angular usando conceptos como <a href="http://es.wikipedia.org/wiki/Torque">torque</a> y <a href="http://es.wikipedia.org/wiki/Momento_de_intercia">momento de inercia</a>. Pero ese nivel de simulación no es el foco de este libro. (Veremos más sobre modelar aceleración angular con un péndulo más adelante en este capítulo, así como también veremos cómo Box2D modela realísticamente los movimientos rotatorios en el capítulo 5.)</p>

<p>Por ahora, una solución rápida y simple bastará. Obtendremos resultados razonables sólo con calcular la aceleración angular como una función del vector de aceleración del objeto. Este es un ejemplo:</p>

<pre data-code-language="java" data-type="programlisting" class="codesplit">
    acelAngular = aceleracion.x;</pre>

<p>Cierto, esto es completamente arbitrario. Pero hace algo. Si el objeto está acelerando hacia la derecha, su rotación angular acelera en el sentido de las manecillas del reloj; aceleración hacia la izquierda genera una rotación en sentido opuesto. Por supuesto, es imporante en este caso también pensar en la escala. El componente <em>x</em> del vector de aceleración quizás es una cantidad demasiado grande, causando que el objeto gire de manera ridícula, o poco realista. Entonces dividir el componente <em>x</em> por algún valor, o quizás limitar la velocidad angular a un rango razonable realmente hará efecto. Acá tenemos la función <code>actualizar()</code> completa, con estos ajustes incorporados. </p>

<figure class="screenshot" data-pde="processingjs/Chapter03/_3_02_forces_angular_motion/_3_02_forces_angular_motion.pde processingjs/Chapter03/_3_02_forces_angular_motion/Attractor.pde processingjs/Chapter03/_3_02_forces_angular_motion/Mover.pde"><img alt="ch03 ex02" src="capitulo03/ch03_ex02.png" />
<figcaption>&nbsp;</figcaption>
</figure>

<div data-type="example"><h5>Ejemplo 3.2: Fuerzas con movimiento angular (arbitrario)</h5></div>

<pre data-code-language="java" data-type="programlisting" class="codesplit">
  void actualizar() {
    velocidad.add(aceleracion);
    posicion.add(velocidad);

    //{!1} Calcula aceleración angular de acuerdo a la dirección horizontal y magnitud de la aceleración.
    acelAngular = aceleracion.x / 10.0;
    velAngular += acelAngular;
    //{!1} Usa constrain() para garantizar que no gire fuera de control.
    velAngular = constrain(velAngular, -0.1, 0.1);
    angulo += velAngular;

    aceleracion.mult(0);
  }</pre>

<div data-type="exercise" id="Capitulo03_exercise2">
<h5>Ejercicio 3.2</h5>

<p>Paso 1: crea una simulación en la cual objetos salen disparados de un cañón. Cada objeto deberá experimentar una fuerza repentina cuando sea disparado (sólo una vez), así como también la fuerza de gravedad siempre presente.</p>

<p>Paso 2: agrega rotación al objeto para modelar su giro mientras sale disparado del cañón. ¿Qué tan realístico lo puedes hacer ver?</p>
</div>
</section>

<section data-type="sect1" id="Capitulo03_section3">
<h2>3.3 Trigonometría</h2>

<a data-primary="&lt;em&gt;sohcahtoa&lt;/em&gt;" data-type="indexterm"></a> <a data-primary="trigonometry" data-type="indexterm"></a> <a data-primary="trigonometry" data-secondary="&lt;em&gt;sohcahtoa&lt;/em&gt;" data-type="indexterm"></a>

<p>Llegó el momento. Leímos sobre ángulos, giramos un objeto. Es la hora de: <em>sohcahtoa</em>. Sí, <em>sohcahtoa</em>. Esta palabra sin sentido es en realidad el concepto fundacional de mucho del trabajo de gráficos computarizados. La comprensión básica de trigonometría es esencial si quieres calcular un ángulo, encontrar la distancia entre dos puntos, trabajar con círculos, arcos, o líneas. Y <em>sohcahtoa</em> es una palabra nemotécnica (por cierto absurda) para recordar qué significa cada una de las funciones trigonométricas: seno, coseno y tangente. </p>

<figure id="Capitulo03_figure4"><img alt="Figure 3.4" src="capitulo03/ch03_04.png" />
<figcaption>Figura 3.4</figcaption>
</figure>

<ul>
	<li>
	<p><strong><em>soh</em></strong>: seno = opuesto / hipotenusa</p>
	</li>
	<li>
	<p><strong><em>cah</em></strong>: coseno = adyacente / hipotenusa</p>
	</li>
	<li>
	<p><strong><em>toa</em></strong>: tangente = opuesto / adyacente</p>
	</li>
</ul>

<figure class="half-width-right" id="Capitulo03_figure5"><img alt="Figure 3.5" src="capitulo03/ch03_05.png" />
<figcaption>Figura 3.5</figcaption>
</figure>

<p>Miremos nuevamente la Figura 3.4. No es necesario memorizarla, pero asegúrante de sentirte cómoda o cómodo con ella. Dibújala. Ahora, dibujémosla de forma un poco diferente (Figura 3.5) </p>

<a data-primary="vectors" data-secondary="as right triangles" data-type="indexterm"></a>

<p>¿Ves como creamos un triángulo rectángulo a partir de un vector? La flecha del vector es la hipotenusa, y los componentes del vector (<code>x</code> e <code>y</code>) son los lados del triángulo. El ángulo es un medio adicional para especificar la dirección del vector (o "avanzando hacia", "heading" en inglés).</p>

<p>Dado que las funciones trigonométricas nos permiten establecer relaciones entre los componentes de un vector y su dirección + magnitud, nos serán muy útiles a lo largo de este libro. Comenzarmos por ver ejemplos que requieren la función tangente.</p>
</section>

<section data-type="sect1" id="Capitulo03_section4">
<h2>3.4 Apuntar en la Dirección del Movimiento.</h2>

<a data-primary="rotation" data-secondary="pointing towards movement" data-type="indexterm"></a>

<p>Volvamos a revisar el Ejemplo 1.10, donde teníamos un objeto <code>caminante</code> acelerando su posición hacia el mouse.</p>

<figure class="screenshot" data-pde="processingjs/Chapter01/_1_10_motion101_acceleration/_1_10_motion101_acceleration.pde processingjs/Capítulo01/_1_10_motion101_acceleration/Mover.pde"><img alt="ch01 ex10" src="capitulo01/ch01_ex10.png" />
<figcaption>&nbsp;</figcaption>
</figure>

<p>Casi todas las formas que hemos dibujado hasta ahora son círculos. Esto es conveniente por una serie de razones, una de las cuales es que no teníamos que considerar el problema de la rotación. Rota un círculo y verás, bueno, lo mismo. Sin embargo, hay un momento en la vida de todo programador de movimiento, donde debe dibujar algo en la pantalla que apunte en la dirección de su movimiento. Tal vez estás dibujando una hormiga, o un auto, o una nave espacial. Y cuando decimos apuntar en la "dirección de su movimiento", lo que realmente estamos diciendo es que el objeto "rote de acuerdo al vector de velocidad". La velocidad es un vector, con componentes <code>x</code> e <code>y</code>, pero para rotar en Processing, necesitamos un ángulo definido en radianes. Volvamos a dibujar nuestro diagrama de trigonometría, con el vector de velocidad de un objeto (Figura 3.6).</p>

<figure class="half-width-right" id="Capitulo03_figure6"><img alt="Figure 3.6" src="capitulo03/ch03_06.png" />
<figcaption>Figura 3.6</figcaption>
</figure>

<a data-primary="tangent" data-type="indexterm"></a> <a data-primary="trigonometry" data-secondary="tangent" data-type="indexterm"></a> <a data-primary="vectors" data-secondary="tangent" data-type="indexterm"></a>

<p>OK. sabemos que la definición de tangente es:</p>

<div class="equation-w-frac-big">
<div data-type="equation">{tangente}({angulo}) = \frac{velocidad_x}{velocidad_y}</div>
</div>

<p>El problema con lo anterior, es que conocemos la velocidad, pero no el ángulo. Debemos descubir el ángulo. Acá es cuando entra en juego una función especial llamada <em>tangente inversa</em>, también conocida como <em>arcotangente</em> o <em>tan <sup>-1</sup></em> (también existen <em>seno inverso</em> y <em>coseno inverso</em>).</p>

<p>Si la tangente de un valor <code></code> es igual a un valor <code>b</code>, entonces la tangente inversa de <code>b</code> equivale a <code>a</code>. Por ejemplo:</p>

<dl>
	<dt><em>si</em></dt>
	<dd>
	<p><em>tangente(a) = b</em></p>
	</dd>
	<dt><em>entonces</em></dt>
	<dd>
	<p><em>a = arcotangente(b)</em></p>
	</dd>
</dl>

<p>¿Ves cómo es el inverso? Con esa fórmula podemos descubrir el ángulo faltante:</p>

<dl>
	<dt><em>si</em></dt>
	<dd>
	<p><em>tangente(angulo) = velocidad<sub>y</sub> / velocidad<sub>x</sub></em></p>
	</dd>
	<dt><em>entonces</em></dt>
	<dd>
	<p><em>angulo = arcotangente(velocidad<sub>y</sub> / velocidad<sub>x</sub>)</em></p>
	</dd>
</dl>

<a data-primary="atan() function (Processing)" data-type="indexterm"></a> <a data-primary="Processing" data-secondary="atan() function" data-type="indexterm"></a> <a data-primary="tangent" data-secondary="atan() function (arctangent)" data-type="indexterm"></a> <a data-primary="trigonometry" data-secondary="atan() function" data-type="indexterm"></a>

<p>Ahora que tenemos la fórmula, veamos hacia dónde debe ir en el código de la función <code>mostrar()</code>. Toma nota que en Processing, la función arcotangente se llama <code>atan()</code>.</p>

<pre data-code-language="java" data-type="programlisting" class="codesplit">
  void mostrar() {
    //{!1} Calcular el ángulo usando atan().
    float angulo = atan(velocidad.y / velocidad.x);

    stroke(0);
    fill(175);
    pushMatrix();
    rectMode(CENTER);
    translate(posicion.x, posicion.y);
    //{!1} Rotar de acuerdo al valor de ángulo.
    rotate(angulo);
    rect(0, 0, 30, 10);
    popMatrix();
  }</pre>

<p>Esto nos deja bastante cerca, y casi funciona. Pero aún tenemos un gran problema. Considera dos vectores de velocidad como los siguientes.</p>

<figure id="Capitulo03_figure7"><img alt="Figure 3.7" src="capitulo03/ch03_07.png" />
<figcaption>Figura 3.7</figcaption>
</figure>

<p>Aunque parezcan similares, ambos vectores apuntan en direcciones diferentes, ¡de hecho, opuestas!. Entonces, si aplicamos nuestra fórmula para encontrar el ángulo de cada vector…</p>

<p><span class="fórmula">V1 &rArr; angulo = atan(3/-4) = atan(-0.75) = -0.6435011 radianes = -37 grados</span><br />
<span class="fórmula">V2 &rArr; angulo = atan(-3/4) = atan(-0.75) = -0.6435011 radianes = -37 grados</span></p>

<a data-primary="atan2() function (Processing)" data-type="indexterm"></a> <a data-primary="Processing" data-secondary="atan2() function" data-type="indexterm"></a> <a data-primary="tangent" data-secondary="atan2() function" data-type="indexterm"></a>

<p>…obtenemos el mismo ángulo para cada vector. Esto no puede estar bien para ambos; ¡los vectores apuntan en sentidos opuestos! La cosa es que esto es algo bastante común en gráficas por computador. En vez de sólo usar <code>atan()</code> y un montón de delcaraciones condicionales para contemplar cada posible escenario positivo/negativo, Procesing (y prácticamente todos los lenguages de programación) tienen otra función llamada <code>atan2()</code> que lo hace por nosotros.</p>

<figure class="screenshot" data-pde="processingjs/Chapter03/_3_03_pointing_velocity/_3_03_pointing_velocity.pde  processingjs/Chapter03/_3_03_pointing_velocity/Mover.pde"><img alt="ch03 ex03" src="capitulo03/ch03_ex03.png" />
<figcaption>&nbsp;</figcaption>
</figure>

<div data-type="example"><h5>Ejemplo 3.3: Apuntando en la dirección del movimiento</h5></div>

<pre data-code-language="java" data-type="programlisting" class="codesplit">
  void mostrar() {
    //{!1} Usemos atan2() para considerar todas las posibles direcciones
    float angulo = atan2(velocidad.y, velocidad.x);

    stroke(0);
    fill(175);
    pushMatrix();
    rectMode(CENTER);
    translate(posicion.x, posicion.y);
    //{!1} Rotar de acuerdo al ese ángulo.
    rotate(angulo);
    rect(0, 0, 30, 10);
    popMatrix();
  }</pre>

<a data-primary="heading() function (PVector class)" data-type="indexterm"></a> <a data-primary="motion" data-secondary="heading() function (PVector class)" data-type="indexterm"></a> <a data-primary="PVector class (Processing)" data-secondary="heading() function" data-type="indexterm"></a> <a data-primary="tangent" data-secondary="heading() function (PVector class)" data-type="indexterm"></a>

<p>Para simplificarlo aún más, la clase <code>PVector</code> incluye una función llamada <code>heading()</code>, que se encarga de llamar a <code>atan2()</code> por nsotros y entrega el ánglo de dirección en 2D, en radianes, para cualquier <code>PVector</code> de Processing.</p>

<pre data-code-language="java" data-type="programlisting" class="codesplit">
    // ¡La forma más fácil de hacerlo!
    float angulo = velocidad.heading();</pre>

<div data-type="exercise" id="Capitulo03_exercise3">
<h5>Ejercicio 3.3</h5>

<p>Crea una simulación de un vehículo que puedas conducir por la pantalla usando las flechas del teclado. Izquierda acelera hacia la izquierda, derecha hacia la derecha. El auto debe apuntar en la dirección en que se está moviendo.</p>
</div>
</section>

<section data-type="sect1" id="Capitulo03_section5">
<h2>3.5 Coordenadas Polares v. Cartesianas</h2>

<a data-primary="Cartesian coordinates" data-type="indexterm"></a> <a data-primary="coordinate systems" data-type="indexterm"></a> <a data-primary="coordinate systems" data-secondary="Cartesian" data-type="indexterm"></a> <a data-primary="Descartes" data-secondary="René" data-type="indexterm"></a> <a data-primary="shapes" data-secondary="displaying" data-type="indexterm"></a>

<p>Cada vez que queremos mostrar una forma en Processing, debemos especificar su posición en pixeles, un par de coordenadas <code>x</code> e <code>y</code>. Estas coordenadas son conocidas como <strong><em>Coordenadas Cartesianas</em></strong>, llamadas así por René Descartes, matemático francés que desarrolló la idea del plano cartesiano.</p>

<a data-primary="coordinate systems" data-secondary="polar" data-type="indexterm"></a> <a data-primary="polar coordinates" data-type="indexterm"></a>

<p>Otro sistema de coordenadas útil llamado <strong><em>Coordenadas Polares</em></strong>, describe un punto en el espacio como el ángulo de rotación alrededor de un origen, y un radio desde dicho origen. Piensa en esto en términos de un vector:</p>

<p></p>
<p>Coordenadas cartesianas—los componentes <em>x</em>,<em>y</em> de un vector<br />
Coordenadas polares—la magnitud (largo) y dirección (ángulo) de un vector./p>

<a data-primary="coordinate systems" data-secondary="Processing and" data-type="indexterm"></a> <a data-primary="Processing" data-secondary="coordinate systems and" data-type="indexterm"></a>

<p>Las funciones de dibujo de Processing no entienden las coordenadas polares. Cada vez que queremos dibujar algo en Processing, tenemos que especificar la posición en pantalla como coordenadas cartesianas <em>(x,y)</em>. Sin embargo, otras veces es mucho más conveniente pensar en coordenadas polares cuando estamos diseñando. Afortunadamente, con trigonometría podemos convertir de ida y vuelta entre coordenadas polares y cartesianas, lo que nos permite diseñar con cualquier sistema de coordenadas que tengamos en mente, pero siempre ubicar en pantalla usando coordenadas cartesianas.</p>

<a data-primary="theta (θ)" data-type="indexterm"></a> <a data-primary="angles" data-secondary="theta (θ)" data-type="indexterm"></a>

<figure id="Capitulo03_figure8"><img alt="Figure 3.8: The Greek letter θ (theta) is often used to denote an angle.  Since a polar coordinate is conventionally referred to as (r, θ), we’ll use theta as a variable name when referring to an angle." src="capitulo03/ch03_08.png" />
<figcaption>Figura 3.8: La letra girega θ (theta) usualmente se utiliza para denotar un ángulo.  Dado que la convención para nombrar coordenadas polares es (r, θ), usaremos theta como nombre de variable para referirnos a un ángulo.&nbsp;</figcaption>
</figure>

<p><span class="fórmula">seno(theta) &nbsp;&nbsp;= y/r &nbsp;&nbsp;&rarr;&nbsp;&nbsp; y = r <code>*</code> seno(theta)</span><br />
<span class="fórmula">coseno(theta) = x/r &nbsp;&nbsp;&rarr;&nbsp;&nbsp; x = r <code>*</code> coseno(theta)</span></p>

<a data-primary="Cartesian coordinates" data-secondary="polar coordinates" data-tertiary="converting from" data-type="indexterm"></a> <a data-primary="cos() function (Processing)" data-type="indexterm"></a> <a data-primary="polar coordinates" data-secondary="Cartesian coordinates" data-tertiary="converting to" data-type="indexterm"></a> <a data-primary="sin() function (Processing)" data-type="indexterm"></a> <a data-primary="trigonometry" data-secondary="cos() function (Processing)" data-type="indexterm"></a> <a data-primary="trigonometry" data-secondary="sin() function (Processing)" data-type="indexterm"></a>

<p>Por ejemplo, si <code>r</code> es 75 y <code>theta</code> es 45 grados (o PI/4 radianes), podemos calcular <code>x</code> y <code>y</code> como se ve a continuación. Las funciones seno y coseno en Processing son <code>sin()</code> y <code>cos()</code> respectivamente. Cada una recibe un argumento, un ángulo medido en radianes.</p>

<pre data-code-language="java" data-type="programlisting" class="codesplit">
float r = 75;
float theta = PI / 4;
// Convertir de polar (r,theta) a cartesiano (x,y)
float x = r * cos(theta);
float y = r * sin(theta);</pre>

<a data-primary="shapes" data-secondary="moving with polar coordinates" data-type="indexterm"></a>

<p>Este tipo de conversión puede ser útil en varias aplicaciones. Por ejemplo, mover una figura alrededor de un trazo circular, utilizando coordenadas cartesianas no es fácil. Con coordenadas polares en cambio, es simple: ¡incrementa el ángulo!</p>

<p>Así podemos hacerlo con variables globales <code>r</code> y <code>theta</code>.</p>

<figure class="screenshot" data-pde="processingjs/Chapter03/_3_04_PolarToCartesian/_3_04_PolarToCartesian.pde"><img alt="ch03 ex04" src="capitulo03/ch03_ex04.png" />
<figcaption>&nbsp;</figcaption>
</figure>

<div data-type="example"><h5>Ejemplo 3.4: de Polar a Cartesiano</h5></div>

<pre data-code-language="java" data-type="programlisting" class="codesplit">
float r = 75;
float theta = 0;

void setup() {
  size(640, 360);
  background(255);
}

void draw() {
  //{!2} Coordenadas polares (r,theta) convertidas a cartesianas (x,y) para usarlas en ellipse()
  float x = r * cos(theta);
  float y = r * sin(theta);

  noStroke();
  fill(0);
  ellipse(x + width/2, y + height/2, 16, 16);

  theta += 0.01;
}</pre>

<div data-type="exercise" id="Capitulo03_exercise4">
<h5>Ejercicio 3.4</h5>

<p>Usando el Ejemplo 3.4 como base, dibuja un trazo espiral. Comienza en el centro, moviéndote hacia afuera. Esto puedes lograrlo sólo con cambiar una línea existente, y agregar una nueva línea de código.</p>

<figure><img alt="ch03 exc04" src="capitulo03/ch03_exc04.png" />
<figcaption>&nbsp;</figcaption>
</figure>
</div>

<div data-type="exercise" id="Capitulo03_exercise5">
<h5>Ejercicio 3.5</h5>

<p>Simula una nave espacial como en el juego Asteroids. Si no conoces el juego, se trata básicamente de lo siguiente: una nave espacial (representada por un triángulo) flota en un espacio bidimensional. En el teclado, la flecha izquierda hace girar a la nave en el sentido contrario a las manecillas del reloj. La flecha derecha, en el sentido de las manecillas. La tecla <em>z</em> le aplica aceleración en la dirección que la nave está apuntando.</p>

<figure class="screenshot" data-pde="processingjs/Chapter03/Ex_3_05_asteroids/Ex_3_05_asteroids.pde processingjs/Chapter03/Ex_3_05_asteroids/Spaceship.pde"><img alt="ch03 exc05" src="capitulo03/ch03_exc05.png" />
<figcaption>&nbsp;</figcaption>
</figure>
</div>
</section>

<section data-type="sect1" id="Capitulo03_section6">
<h2>3.6 Oscillation Amplitude and Period</h2>

<a data-primary="oscillation" data-type="indexterm"></a>

<p>Are you amazed yet? We’ve seen some pretty great uses of tangent (for finding the angle of a vector) and sine and cosine (for converting from polar to Cartesian coordinates). We could stop right here and be satisfied. But we’re not going to. This is only the beginning. What sine and cosine can do for you goes beyond mathematical fórmulas and right triangles.</p>

<p>Let’s take a look at a graph of the sine function, where <em>y = sine(x)</em>.</p>

<figure id="Capitulo03_figure9"><img alt="Figure 3.9: y = sine(x)" src="capitulo03/ch03_09.png" />
<figcaption>Figure 3.9: y = sine(x)</figcaption>
</figure>

<p>You’ll notice that the output of the sine function is a smooth curve alternating between &minus;1 and 1. This type of a behavior is known as <strong><em>oscillation</em></strong>, a periodic movement between two points. Plucking a guitar string, swinging a pendulum, bouncing on a pogo stick—these are all examples of oscillating motion.</p>

<a data-primary="oscillation" data-secondary="simulating with sine curves" data-type="indexterm"></a>

<p>And so we happily discover that we can simulate oscillation in a Processing sketch by assigning the output of the sine function to an object’s position. Note that this will follow the same methodology we applied to Perlin noise in the <a href="#intro_section6">Introduction</a>.</p>

<p>Let’s begin with a really basic scenario. We want a circle to oscillate from the left side to the right side of a Processing window.</p>

<figure class="screenshot" data-pde="processingjs/Chapter03/_3_05_simple_harmonic_motion/_3_05_simple_harmonic_motion.pde"><img alt="ch03 ex05" src="capitulo03/ch03_ex05.png" />
<figcaption>&nbsp;</figcaption>
</figure>

<a data-primary="oscillation" data-secondary="simple harmonic motion" data-type="indexterm"></a> <a data-primary="simple harmonic motion" data-type="indexterm"></a>

<p>This is what is known as <strong><em>simple harmonic motion</em></strong> (or, to be fancier, “the periodic sinusoidal oscillation of an object”). It’s going to be a simple program to write, but before we get into the code, let’s familiarize ourselves with some of the terminology of oscillation (and waves).</p>

<p>Simple harmonic motion can be expressed as any position (in our case, the <code>x</code> position) as a function of time, with the following two elements:</p>

<a data-primary="amplitude" data-type="indexterm"></a> <a data-primary="oscillation" data-secondary="amplitude" data-type="indexterm"></a> <a data-primary="oscillation" data-secondary="period" data-type="indexterm"></a> <a data-primary="period" data-type="indexterm"></a>

<ul>
	<li>
	<p><strong><em>Amplitude</em></strong>: The distance from the center of motion to either extreme</p>
	</li>
	<li>
	<p><strong><em>Period</em></strong>: The amount of time it takes for one complete cycle of motion</p>
	</li>
</ul>

<p>Looking at the graph of sine (Figure 3.9), we can see that the amplitude is 1 and the period is <code>TWO_PI</code>; the output of sine never rises above 1 or below -1; and every <code>TWO_PI</code> radians (or 360 degrees) the wave pattern repeats.</p>

<p>Now, in the Processing world we live in, what is amplitude and what is period? Amplitude can be measured rather easily in pixels. In the case of a window 200 pixels wide, we would oscillate from the center 100 pixels to the right and 100 pixels to the left. Therefore:</p>

<pre data-code-language="java" data-type="programlisting" class="codesplit">
// Our amplitude is measured in pixels.
float amplitude = 100;</pre>

<a data-primary="millis() function (Processing)" data-type="indexterm"></a> <a data-primary="Processing" data-secondary="measuring time in" data-type="indexterm"></a> <a data-primary="time" data-secondary="millis() function" data-tertiary="measuring with" data-type="indexterm"></a> <a data-primary="period" data-type="indexterm"></a>

<p><em>Period</em> is the amount of time it takes for one cycle, but what is time in our Processing world? I mean, certainly we could say we want the circle to oscillate every three seconds. And we could track the milliseconds—using <code>millis()</code> —in Processing and come up with an elaborate algorithm for oscillating an object according to real-world time. But for us, real-world time doesn’t really matter. The real measure of time in Processing is in frames. The oscillating motion should repeat every 30 frames, or 50 frames, or 1000 frames, etc.</p>

<pre data-code-language="java" data-type="programlisting" class="codesplit">
// Period is measured in frames (the unit of time for animation).
float period = 120;</pre>

<p>Once we have the amplitude and period, it’s time to write a fórmula to calculate x as a function of time, which we now know is the current frame count.</p>

<pre data-code-language="java" data-type="programlisting" class="codesplit">
float x = amplitude * sin(TWO_PI * frameCount / period);</pre>

<a data-primary="map() function (Processing)" data-secondary="oscillation and" data-type="indexterm"></a>

<p>Let’s dissect the fórmula a bit more and try to understand each component. The first is probably the easiest. Whatever comes out of the sine function we multiply by amplitude. We know that sine will oscillate between -1 and 1. If we take that value and multiply it by amplitude then we’ll get the desired result: a value oscillating between -amplitude and amplitude. (Note: this is also a place where we could use Processing’s <code>map()</code> function to map the output of sine to a custom range.)</p>

<p>Now, let’s look at what is inside the sine function:</p>

<p><span class="fórmula">TWO_PI <code>*</code> frameCount / period</span></p>

<p>What’s going on here? Let’s start with what we know. We know that sine will repeat every 2*PI radians—i.e. it will start at 0 and repeat at 2*PI, 4*PI, 6*PI, etc. If the period is 120, then we want the oscillating motion to repeat when the <code>frameCount</code> is at 120 frames, 240 frames, 360 frames, etc. <code>frameCount</code> is really the only variable; it starts at 0 and counts upward. Let’s take a look at what the fórmula yields with those values.</p>

<table>
	<thead>
		<tr>
			<th>frameCount</th>
			<th>frameCount / period</th>
			<th>TWO_PI * frameCount / period</th>
		</tr>
	</thead>
	<tbody>
		<tr>
			<td>
			<p>0</p>
			</td>
			<td>
			<p>0</p>
			</td>
			<td>
			<p>0</p>
			</td>
		</tr>
		<tr>
			<td>
			<p>60</p>
			</td>
			<td>
			<p>0.5</p>
			</td>
			<td>
			<p>PI</p>
			</td>
		</tr>
		<tr>
			<td>
			<p>120</p>
			</td>
			<td>
			<p>1</p>
			</td>
			<td>
			<p>TWO_PI</p>
			</td>
		</tr>
		<tr>
			<td>
			<p>240</p>
			</td>
			<td>
			<p>2</p>
			</td>
			<td>
			<p>2 * TWO_PI (or 4* PI)</p>
			</td>
		</tr>
		<tr>
			<td>
			<p>etc.</p>
			</td>
			<td>&nbsp;</td>
			<td>&nbsp;</td>
		</tr>
	</tbody>
</table>

<p><code>frameCount</code> divided by <code>period</code> tells us how many cycles we’ve completed—are we halfway through the first cycle? Have we completed two cycles? By multiplying that number by <code>TWO_PI</code>, we get the result we want, since <code>TWO_PI</code> is the number of radians required for one sine (or cosine) to complete one cycle.</p>

<p>Wrapping this all up, here’s the Processing example that oscillates the <code>x</code> position of a circle with an amplitude of 100 pixels and a period of 120 frames.</p>

<div data-type="example"><h5>Example 3.5: Simple Harmonic Motion</h5></div>

<pre data-code-language="java" data-type="programlisting" class="codesplit">
void setup() {
  size(640, 360);
}

void draw() {
  background(255);

  float period = 120;
  float amplitude = 100;
  //{!1 .offset} Calculating horizontal position according to the fórmula for simple harmonic motion
  float x = amplitude * sin(TWO_PI * frameCount / period);
  stroke(0);
  fill(175);
  translate(width/2, height/2);
  line(0, 0, x, 0);
  ellipse(x, 0, 20, 20);
}</pre>

<a data-primary="frequency (of oscillations)" data-type="indexterm"></a> <a data-primary="oscillation" data-secondary="frequency of" data-type="indexterm"></a>

<p>It’s also worth mentioning the term <strong><em>frequency</em></strong>: the number of cycles per time unit. Frequency is equal to 1 divided by <code>period</code>. If the period is 120 frames, then only 1/120th of a cycle is completed in one frame, and so frequency = 1/120. In the above example, we simply chose to define the rate of oscillation in terms of period and therefore did not need a variable for frequency.</p>

<div data-type="exercise" id="Capitulo03_exercise6">
<h5>Exercise 3.6</h5>

<p>Using the sine function, create a simulation of a weight (sometimes referred to as a “bob”) that hangs from a spring from the top of the window. Use the <code>map()</code> function to calculate the vertical position of the bob. Later in this Capítulo, we’ll see how to recreate this same simulation by modeling the forces of a spring according to Hooke’s law.</p>
</div>
</section>

<section data-type="sect1" id="Capitulo03_section7">
<h2>3.7 Oscillation with Angular Velocity</h2>

<a data-primary="angular velocity" data-secondary="oscillation with" data-type="indexterm"></a> <a data-primary="oscillation" data-secondary="angular velocity and" data-type="indexterm"></a>

<p>An understanding of the concepts of oscillation, amplitude, and frequency/period is often required in the course of simulating real-world behaviors. However, there is a slightly easier way to rewrite the above example with the same result. Let’s take one more look at our oscillation fórmula:</p>

<pre data-code-language="java" data-type="programlisting" class="codesplit">
float x = amplitude * sin(TWO_PI * frameCount / period);</pre>

<p>And let’s rewrite it a slightly different way:</p>

<pre data-code-language="java" data-type="programlisting" class="codesplit">
float x = amplitude * sin ( some value that increments slowly );</pre>

<p>If we care about precisely defining the period of oscillation in terms of frames of animation, we might need the fórmula the way we first wrote it, but we can just as easily rewrite our example using the concept of angular velocity (and acceleration) from <a href="#Capítulo03_section2">section 3.2</a>. Assuming:</p>

<pre data-code-language="java" data-type="programlisting" class="codesplit">
float angle = 0;
float aVelocity = 0.05;</pre>

<p>in <code>draw()</code>, we can simply say:</p>

<pre data-code-language="java" data-type="programlisting" class="codesplit">
angle += aVelocity;
float x = amplitude * sin(angle);</pre>

<p><code>angle</code> is our “some value that increments slowly.”</p>

<div data-type="example"><h5>Example 3.6: Simple Harmonic Motion II</h5></div>

<pre data-code-language="java" data-type="programlisting" class="codesplit">
float angle = 0;
float aVelocity = 0.05;

void setup() {
  size(640, 360);
}

void draw() {
  background(255);

  float amplitude = 100;
  float x = amplitude * sin(angle);
  //{!1} Using the concept of angular velocity to increment an angle variable
  angle += aVelocity;

  ellipseMode(CENTER);
  stroke(0);
  fill(175);
  translate(width/2, height/2);
  line(0, 0, x, 0);
  ellipse(x, 0, 20, 20);
}</pre>

<p>Just because we’re not referencing it directly doesn’t mean that we’ve eliminated the concept of <code>period</code>. After all, the greater the angular velocity, the faster the circle will oscillate (therefore lowering the period). In fact, the number of times it takes to add up the angular velocity to get to <code>TWO_PI</code> is the period or:</p>

<p><span class="fórmula">period = TWO_PI / angular velocity</span></p>

<a data-primary="oscillation" data-secondary="on two axes" data-type="indexterm"></a>

<p>Let’s expand this example a bit more and create an <code>Oscillator</code> class. And let’s assume we want the oscillation to happen along both the x-axis (as above) and the y-axis. To do this, we’ll need two angles, two angular velocities, and two amplitudes (one for each axis). Another perfect opportunity for <code>PVector</code>!</p>

<figure class="screenshot" data-pde="processingjs/Chapter03/_3_07_oscillating_objects/_3_07_oscillating_objects.pde processingjs/Chapter03/_3_07_oscillating_objects/Oscillator.pde"><img alt="ch03 ex07" src="capitulo03/ch03_ex07.png" />
<figcaption>&nbsp;</figcaption>
</figure>

<div data-type="example"><h5>Example 3.7: Oscillator objects</h5></div>

<pre data-code-language="java" data-type="programlisting" class="codesplit">
class Oscillator  {

  //{!3} Using a PVector to track two angles!
  PVector angle;
  PVector velocity;
  PVector amplitude;

  Oscillator()  {
    angle = new PVector();
    velocity = new PVector(random(-0.05,0.05),random(-0.05,0.05));
    //{!1 .offset} Random velocities and amplitudes
    amplitude = new PVector(random(width/2), random(height/2));
  }

  void oscillate()  {
    angle.add(velocity);
  }

  void display()  {
    // Oscillating on the x-axis
    float x = sin(angle.x) * amplitude.x;
    //{!1} Oscillating on the y-axis
    float y = sin(angle.y) * amplitude.y;

    pushMatrix();
    translate(width/2, height/2);
    stroke(0);
    fill(175);
    // Drawing the Oscillator as a line connecting a circle
    line(0, 0, x, y);
    ellipse(x, y, 16, 16);
    popMatrix();
  }
}</pre>

<div data-type="exercise" id="Capitulo03_exercise7">
<h5>Exercise 3.7</h5>

<p>Try initializing each <code>Oscillator</code> object with velocities and amplitudes that are not random to create some sort of regular pattern. Can you make the oscillators appear to be the legs of an insect-like creature?</p>
</div>

<div data-type="exercise" id="Capitulo03_exercise8">
<h5>Exercise 3.8</h5>

<p>Incorporate angular acceleration into the <code>Oscillator</code> object.</p>
</div>
</section>

<section data-type="sect1" id="Capitulo03_section8">
<h2>3.8 Waves</h2>

<a data-primary="oscillation" data-secondary="waves" data-type="indexterm"></a> <a data-primary="waves" data-type="indexterm"></a>

<p>If you’re saying to yourself, “Um, this is all great and everything, but what I really want is to draw a wave onscreen,” well, then, the time has come. The thing is, we’re about 90% there. When we oscillate a single circle up and down according to the sine function, what we are doing is looking at a single point along the x-axis of a wave pattern. With a little panache and a <code>for</code> loop, we can place a whole bunch of these oscillating circles next to each other.</p>

<figure class="screenshot" data-pde="processingjs/Chapter03/_3_09_wave/_3_09_wave.pde"><img alt="ch03 ex09" src="capitulo03/ch03_ex09.png" />
<figcaption>&nbsp;</figcaption>
</figure>

<p>This wavy pattern could be used in the design of the body or appendages of a creature, as well as to simulate a soft surface (such as water).</p>

<a data-primary="period" data-secondary="defined in pixels rather than frames" data-type="indexterm"></a> <a data-primary="waves" data-secondary="angular velocity" data-tertiary="defining with" data-type="indexterm"></a>

<p>Here, we’re going to encounter the same questions of amplitude (height of pattern) and period. Instead of period referring to time, however, since we’re looking at the full wave, we can talk about period as the width (in pixels) of a full wave cycle. And just as with simple oscillation, we have the option of computing the wave pattern according to a precise period or simply following the model of angular velocity.</p>

<p>Let’s go with the simpler case, angular velocity. We know we need to start with an angle, an angular velocity, and an amplitude:</p>

<pre data-code-language="java" data-type="programlisting" class="codesplit">
float angle = 0;
float angleVel = 0.2;
float amplitude = 100;</pre>

<p>Then we’re going to loop through all of the <code>x</code> values where we want to draw a point of the wave. Let’s say every 24 pixels for now. In that loop, we’re going to want to do three things:</p>

<ol>
	<li>
	<p>Calculate the y position according to amplitude and sine of the angle.</p>
	</li>
	<li>
	<p>Draw a circle at the <em>(x,y)</em> position.</p>
	</li>
	<li>
	<p>Increment the angle according to angular velocity.</p>
	</li>
</ol>

<pre data-code-language="java" data-type="programlisting" class="codesplit">
  for (int x = 0; x &lt;= width; x += 24) {
    // 1) Calculate the y position according to amplitude and sine of the angle.
    float y = amplitude * sin(angle);
    // 2) Draw a circle at the (x,y) position.
    ellipse(x, y + height/2, 48, 48);
    // 3) Increment the angle according to angular velocity.
    angle += angleVel;
  }</pre>

<p>Let’s look at the results with different values for <code>angleVel</code>:</p>

<figure class="three-col" data-pde="processingjs/Chapter03/_3_09_wave_a/_3_09_wave_a.pde"><img alt="angleVel = 0.05" src="capitulo03/ch03_ex09a.png" />
<figcaption>angleVel = 0.05&nbsp;</figcaption>
</figure>

<figure class="three-col" data-pde="processingjs/Chapter03/_3_09_wave_b/_3_09_wave_b.pde"><img alt="angleVel = 0.2" src="capitulo03/ch03_ex09b.png" />
<figcaption>angleVel = 0.2&nbsp;</figcaption>
</figure>

<figure class="three-col" data-pde="processingjs/Chapter03/_3_09_wave_c/_3_09_wave_c.pde"><img alt="angleVel = 0.4" src="capitulo03/ch03_ex09c.png" />
<figcaption>angleVel = 0.4&nbsp;</figcaption>
</figure>

<p>Notice how, although we’re not precisely computing the period of the wave, the higher the angular velocity, the shorter the period. It’s also worth noting that as the period becomes shorter, it becomes more and more difficult to make out the wave itself as the distance between the individual points increases. One option we have is to use <code>beginShape()</code> and <code>endShape()</code> to connect the points with a line.</p>

<figure class="screenshot" data-pde="processingjs/Chapter03/_3_08_static_wave_lines/_3_08_static_wave_lines.pde"><img alt="ch03 ex08" src="capitulo03/ch03_ex08.png" />
<figcaption>&nbsp;</figcaption>
</figure>

<div data-type="example"><h5>Example 3.8: Static wave drawn as a continuous line</h5></div>

<pre data-code-language="java" data-type="programlisting" class="codesplit">
float angle = 0;
float angleVel = 0.2;
float amplitude = 100;

size(400, 200);
background(255);

stroke(0);
strokeWeight(2);
noFill();

beginShape();
for (int x = 0; x &lt;= width; x += 5) {
  // Here’s an example of using the map() function
  // instead.
  float y = map(sin(angle), -1, 1, 0, height);
  // With beginShape() and endShape(), you call
  // vertex() to set all the vertices of your shape.
  vertex(x, y);
  angle += angleVel;
}
endShape();</pre>

<a data-primary="oscillation" data-secondary="varying" data-type="indexterm"></a> <a data-primary="waves" data-secondary="varying" data-type="indexterm"></a>

<p>You may have noticed that the above example is static. The wave never changes, never undulates. This additional step is a bit tricky. Your first instinct might be to say: “Hey, no problem, we’ll just let theta be a global variable and let it increment from one cycle through <code>draw()</code> to another.”</p>

<p>While it’s a nice thought, it doesn’t work. If you look at the wave, the righthand edge doesn’t match the lefthand; where it ends in one cycle of <code>draw()</code> can’t be where it starts in the next. Instead, what we need to do is have a variable dedicated entirely to tracking what value of angle the wave should start with. This angle (which we’ll call <code>startAngle</code>) increments with its own angular velocity.</p>

<figure class="screenshot" data-pde="processingjs/Chapter03/_3_09_wave/_3_09_wave.pde"><img alt="ch03 ex09" src="capitulo03/ch03_ex09.png" />
<figcaption>&nbsp;</figcaption>
</figure>

<div data-type="example"><h5>Example 3.9: The Wave</h5></div>

<pre data-code-language="java" data-type="programlisting" class="codesplit">
float startAngle = 0;
float angleVel = 0.1;

void setup() {
  size(400, 200);
}

void draw() {
  background(255);

  //{!2} In order to move the wave, we start at a different theta value each frame.
  float angle = startAngle;
  startAngle += 0.02;

  for (int x = 0; x &lt;= width; x += 24) {
    float y = map(sin(angle),-1,1,0,height);
    stroke(0);
    fill(0,50);
    ellipse(x,y,48,48);
    angle += angleVel;
  }
}</pre>

<div data-type="exercise" id="Capitulo03_exercise9">
<h5>Exercise 3.9</h5>

<p>Try using the Perlin noise function instead of sine or cosine with the above example.</p>
</div>

<div data-type="exercise" id="Capitulo03_exercise10">
<h5>Exercise 3.10</h5>

<p>Encapsulate the above examples into a <code>Wave</code> class and create a sketch that displays two waves (with different amplitudes/periods) as in the screenshot below. Move beyond plain circles and lines and try visualizing the wave in a more creative way.</p>

<figure data-pde="processingjs/Chapter03/Ex_3_10_OOPWave/Ex_3_10_OOPWave.pde processingjs/Chapter03/Ex_3_10_OOPWave/Wave.pde"><img alt="ch03 exc10" src="capitulo03/ch03_exc10.png" />
<figcaption>&nbsp;</figcaption>
</figure>
</div>

<div data-type="exercise" id="Capitulo03_exercise11">
<h5>Exercise 3.11</h5>

<p>More complex waves can be produced by the values of multiple waves together. Create a sketch that implements this, as in the screenshot below.</p>

<figure data-pde="processingjs/Chapter03/Ex_3_11_AdditiveWave/Ex_3_11_AdditiveWave.pde"><img alt="ch03 exc11" src="capitulo03/ch03_exc11.png" />
<figcaption>&nbsp;</figcaption>
</figure>
</div>
</section>

<section data-type="sect1" id="Capitulo03_section9">
<h2>3.9 Trigonometry and Forces: The Pendulum</h2>

<a data-primary="forces" data-secondary="trigonometry and" data-type="indexterm"></a> <a data-primary="natural phenomena" data-secondary="pivots" data-tertiary="modeling" data-type="indexterm"></a> <a data-primary="pivots" data-secondary="modeling" data-type="indexterm"></a> <a data-primary="trigonometry" data-secondary="forces and" data-type="indexterm"></a>

<p>Do you miss Newton’s laws of motion? I know I sure do. Well, lucky for you, it’s time to bring it all back home. After all, it’s been nice learning about triangles and tangents and waves, but really, the core of this book is about simulating the physics of moving bodies. Let’s take a look at how trigonometry can help us with this pursuit.</p>

<figure class="two-col-borderless" id="Capitulo03_figure10"><img alt="Figure 3.10" src="capitulo03/ch03_10.png" />
<figcaption>Figure 3.10</figcaption>
</figure>

<figure class="two-col-borderless" id="Capitulo03_figure11"><img alt="Figure 3.11" src="capitulo03/ch03_11.png" />
<figcaption>Figure 3.11</figcaption>
</figure>

<p>A pendulum is a bob suspended from a pivot. Obviously a real-world pendulum would live in a 3D space, but we’re going to look at a simpler scenario, a pendulum in a 2D space—a Processing window (see Figure 3.10).</p>

<a data-primary="acceleration" data-secondary="angular" data-tertiary="determining" data-type="indexterm"></a> <a data-primary="angular acceleration" data-type="indexterm"></a>

<p>In Capítulo 2, we learned how a force (such as the force of gravity in Figure 3.11) causes an object to accelerate. <span class="mono">F = M <code>*</code> A</span> or <span class="mono">A = F / M</span>. In this case, however, the pendulum bob doesn’t simply fall to the ground because it is attached by an arm to the pivot point. And so, in order to determine its <em>angular</em> acceleration, we not only need to look at the force of gravity, but also the force at the angle of the pendulum’s arm (relative to a pendulum at rest with an angle of 0).</p>

<p>In the above case, since the pendulum’s arm is of fixed length, the only variable in the scenario is the angle. We are going to simulate the pendulum’s motion through the use of angular velocity and acceleration. The angular acceleration will be calculated using Newton’s second law with a little trigonometry twist.</p>

<p>Let’s zoom in on the right triangle from the pendulum diagram.</p>

<figure class="half-width-right" id="Capitulo03_figure12"><img alt="Figure 3.12" src="capitulo03/ch03_12.png" />
<figcaption>Figure 3.12</figcaption>
</figure>

<a data-primary="gravity" data-secondary="modeling with trigonometry" data-type="indexterm"></a>

<p>We can see that the force of the pendulum (<code>F<sub>p</sub></code>) should point perpendicular to the arm of the pendulum in the direction that the pendulum is swinging. After all, if there were no arm, the bob would just fall straight down. It’s the tension force of the arm that keeps the bob accelerating towards the pendulum’s rest state. Since the force of gravity (<code>F<sub>g</sub></code>) points downward, by making a right triangle out of these two vectors, we’ve accomplished something quite magnificent. We’ve made the force of gravity the hypotenuse of a right triangle and separated the vector into two components, one of which represents the force of the pendulum. Since sine equals opposite over hypotenuse, we have:</p>

<p><span class="fórmula">sine(&theta;) = F<sub>p</sub> / F<sub>g</sub></span></p>

<p>Therefore:</p>

<p><span class="fórmula">F<sub>p</sub> = F<sub>g</sub> <code>*</code> sine(&theta;)</span></p>

<p>Lest we forget, we’ve been doing all of this with a single question in mind: What is the angular acceleration of the pendulum? Once we have the angular acceleration, we’ll be able to apply our rules of motion to find the new angle for the pendulum.</p>

<p><span class="fórmula">angular velocity = angular velocity + angular acceleration</span><br />
<span class="fórmula">angle = angle + angular velocity</span></p>

<p>The good news is that with Newton’s second law, we know that there is a relationship between force and acceleration, namely F = M * A, or A = F / M. So if the force of the pendulum is equal to the force of gravity times sine of the angle, then:</p>

<p><span class="fórmula">pendulum angular acceleration = acceleration due to gravity <code>*</code> sine (&theta;)</span></p>

<a data-primary="gravity" data-secondary="modeling reality vs. arbitrary values" data-type="indexterm"></a> <a data-primary="natural phenomena" data-secondary="modeling reality vs. arbitrary values" data-type="indexterm"></a>

<p>This is a good time to remind ourselves that we’re Processing programmers and not physicists. Yes, we know that the acceleration due to gravity on earth is 9.8 meters per second squared. But this number isn’t relevant to us. What we have here is just an arbitrary constant (we’ll call it <code>gravity</code>), one that we can use to scale the acceleration to something that feels right.</p>

<p><span class="fórmula">angular acceleration = gravity <code>*</code> sine(&theta;)</span></p>

<p>Amazing. After all that, the fórmula is so simple. You might be wondering, why bother going through the derivation at all? I mean, learning is great and all, but we could have easily just said, "Hey, the angular acceleration of a pendulum is some constant times the sine of the angle." This is just another moment in which we remind ourselves that the purpose of the book is not to learn how pendulums swing or gravity works. The point is to think creatively about how things can move about the screen in a computationally based graphics system. The pendulum is just a case study. If you can understand the approach to programming a pendulum, then however you choose to design your onscreen world, you can apply the same techniques.</p>

<p>Of course, we’re not finished yet. We may be happy with our simple, elegant fórmula, but we still have to apply it in code. This is most definitely a good time to practice our object-oriented programming skills and create a <code>Pendulum</code> class. Let’s think about all the properties we’ve encountered in our pendulum discussion that the class will need:</p>

<ul>
	<li>
	<p>arm length</p>
	</li>
	<li>
	<p>angle</p>
	</li>
	<li>
	<p>angular velocity</p>
	</li>
	<li>
	<p>angular acceleration</p>
	</li>
</ul>

<pre data-code-language="java" data-type="programlisting" class="codesplit">
class Pendulum  {

  // Length of arm
  float r;
  // Pendulum arm angle
  float angle;
  // Angular velocity
  float aVelocity;
  // Angular acceleration
  float aAcceleration;</pre>

<p>We’ll also need to write a function <code>update()</code> to update the pendulum’s angle according to our fórmula…</p>

<pre data-code-language="java" data-type="programlisting" class="codesplit">
  void update() {
    // Arbitrary constant
    float gravity = 0.4;
    // Calculate acceleration according to our fórmula.
    aAcceleration = -1 * gravity * sin(angle);
    // Increment velocity.
    aVelocity += aAcceleration;
    //{!1} Increment angle.
    angle += aVelocity;
  }</pre>

<figure class="half-width-right" id="Capitulo03_figure13"><img alt="Figure 3.13" src="capitulo03/ch03_13.png" />
<figcaption>Figure 3.13</figcaption>
</figure>

<p>...as well as a function <code>display()</code> to draw the pendulum in the window. This begs the question: “Um, where do we draw the pendulum?” We know the angle and the arm length, but how do we know the <em>x,y</em> (Cartesian!) coordinates for both the pendulum’s pivot point (let’s call it origin) and bob position (let’s call it position)? This may be getting a little tiring, but the answer, yet again, is trigonometry.</p>

<p>The origin is just something we make up, as is the arm length. Let’s say:</p>

<pre data-code-language="java" data-type="programlisting" class="codesplit">
PVector origin = new PVector(100,10);
float r = 125;</pre>

<p>We’ve got the current angle stored in our variable <code>angle</code>. So relative to the origin, the pendulum’s position is a polar coordinate: <em>(r,angle)</em>. And we need it to be Cartesian. Luckily for us, we just spent some time (section 3.5) deriving the fórmula for converting from polar to Cartesian. And so:</p>

<pre data-code-language="java" data-type="programlisting" class="codesplit">
PVector position = new PVector(r * sin(angle), r* cos(angle));</pre>

<p>Note, however that <code>sin(angle)</code> is used for the x-value and <code>cos(angle)</code> for the y.  This is the opposite of the fórmula we established in Capítulo 3.  The reason for this is that we are looking for the top angle of the right-triangle pointing down as depicted in Figure 3.13.</p>

<p>Since the position is relative to wherever the origin happens to be, we can just add origin to the position <code>PVector</code>:</p>

<pre data-code-language="java" data-type="programlisting" class="codesplit">
position.add(origin);</pre>

<p>And all that remains is the little matter of drawing a line and ellipse (you should be more creative, of course).</p>

<pre data-code-language="java" data-type="programlisting" class="codesplit">
stroke(0);
fill(175);
line(origin.x, origin.y, position.x, position.y);
ellipse(position.x, position.y, 16, 16);</pre>

<p>Before we put everything together, there’s one last little detail I neglected to mention. Let’s think about the pendulum arm for a moment. Is it a metal rod? A string? A rubber band? How is it attached to the pivot point? How long is it? What is its mass? Is it a windy day? There are a lot of questions that we could continue to ask that would affect the simulation. We’re living, of course, in a fantasy world, one where the pendulum’s arm is some idealized rod that never bends and the mass of the bob is concentrated in a single, infinitesimally small point. Nevertheless, even though we don’t want to worry ourselves with all of the questions, we should add one more variable to our calculation of angular acceleration. To keep things simple, in our derivation of the pendulum’s acceleration, we assumed that the length of the pendulum’s arm is 1. In fact, the length of the pendulum’s arm affects the acceleration greatly: the longer the arm, the slower the acceleration. To simulate a pendulum more accurately, we divide by that length, in this case <code>r</code>. For a more involved explanation, visit <a href="http://calculuslab.deltacollege.edu/ODE/7-A-2/7-A-2-h.html">The Simple Pendulum website</a>.</p>

<pre data-code-language="java" data-type="programlisting" class="codesplit">
aAcceleration = (-1 * G * sin(angle)) / r;</pre>

<a data-primary="acceleration" data-secondary="damping" data-type="indexterm"></a> <a data-primary="damping" data-type="indexterm"></a> <a data-primary="forces" data-secondary="damping" data-type="indexterm"></a> <a data-primary="friction" data-secondary="damping" data-type="indexterm"></a>

<p>Finally, a real-world pendulum is going to experience some amount of friction (at the pivot point) and air resistance. With our code as is, the pendulum would swing forever, so to make it more realistic we can use a “damping” trick. I say <em>trick</em> because rather than model the resistance forces with some degree of accuracy (as we did in Capítulo 2), we can achieve a similar result by simply reducing the angular velocity during each cycle. The following code reduces the velocity by 1% (or multiplies it by 99%) during each frame of animation:</p>

<pre data-code-language="java" data-type="programlisting" class="codesplit">
aVelocity *= 0.99;</pre>

<p>Putting everything together, we have the following example (with the pendulum beginning at a 45-degree angle).</p>

<figure class="screenshot" data-pde="processingjs/Chapter03/_3_10_PendulumExample/_3_10_PendulumExample.pde processingjs/Chapter03/_3_10_PendulumExample/Pendulum.pde"><img alt="ch03 ex10" src="capitulo03/ch03_ex10.png" />
<figcaption>&nbsp;</figcaption>
</figure>

<div data-type="example"><h5>Example 3.10: Swinging pendulum</h5></div>

<pre data-code-language="java" data-type="programlisting" class="codesplit">
Pendulum p;

void setup() {
  size(640, 360);
  //{!1} We make a new Pendulum object with an origin position and arm length.
  p = new Pendulum(new PVector(width/2,10),125);
}

void draw() {
  background(255);
  p.go();
}</pre>
<pre data-code-language="java" data-type="programlisting" class="codesplit">
class Pendulum  {
  //{!7} Many, many variables to keep track of the Pendulum’s various properties
  PVector position;    // position of bob
  PVector origin;      // position of arm origin
  float r;             // Length of arm
  float angle;         // Pendulum arm angle
  float aVelocity;     // Angle velocity
  float aAcceleration; // Angle acceleration
  float damping;       // Arbitrary damping amount

  Pendulum(PVector origin_, float r_) {
    origin = origin_.copy();
    position = new PVector();
    r = r_;
    angle = PI/4;

    aVelocity = 0.0;
    aAcceleration = 0.0;
    // An arbitrary damping so that the Pendulum slows over time
    damping = 0.995;
  }

  void go() {
    update();
    display();
  }

  void update() {
    float gravity = 0.4;
    //{!1 .code-wide} Formula we worked out for angular acceleration
    aAcceleration = (-1 * gravity / r) * sin(angle);

    //{!2} Standard angular motion algorithm
    aVelocity += aAcceleration;
    angle += aVelocity;

    // Apply some damping.
    aVelocity *= damping;
  }

  void display() {
    //{!1} Where is the bob relative to the origin? Polar to Cartesian coordinates will tell us!
    position.set(r * sin(angle), r * cos(angle));
    position.add(origin);

    stroke(0);
    //{!1 .code-wide} The arm
    line(origin.x, origin.y, position.x, position.y);
    fill(175);
    //{!1 .code-wide} The bob
    ellipse(position.x, position.y, 16, 16);
  }
}</pre>

<p><em>(Note that the version of the example posted on the website has additional code to allow the user to grab the pendulum and swing it with the mouse.)</em></p>

<div data-type="exercise" id="Capitulo03_exercise12">
<h5>Exercise 3.12</h5>

<p>String together a series of pendulums so that the endpoint of one is the origin point of another. Note that doing this may produce intriguing results but will be wildly inaccurate physically. Simulating an actual double pendulum involves sophisticated equations, which you can read about here: <a href="http://scienceworld.wolfram.com/physics/DoublePendulum.html"><em class="hyperlink">http://scienceworld.wolfram.com/physics/DoublePendulum.html</em></a>.</p>
</div>

<div data-type="exercise" id="Capitulo03_exercise13">
<h5>Exercise 3.13</h5>

<figure class="half-width-right"><img alt="ch03 exc13" src="capitulo03/ch03_exc13.png" />
<figcaption>&nbsp;</figcaption>
</figure>

<p>Using trigonometry, what is the magnitude of the normal force in the illustration on the right (the force perpendicular to the incline on which the sled rests)? Note that, as indicated, the “normal” force is a component of the force of gravity.</p>

<figure><img alt="blank" src="blank.png" />
<figcaption>&nbsp;</figcaption>
</figure>
</div>

<div data-type="exercise" id="Capitulo03_exercise14">
<h5>Exercise 3.14</h5>

<p>Create an example that simulates a box sliding down the incline with friction. Note that the magnitude of the friction force is equal to the normal force.</p>
</div>
</section>

<section data-type="sect1" id="Capitulo03_section10">
<h2>3.10 Spring Forces</h2>

<a data-primary="forces" data-secondary="springs" data-type="indexterm"></a> <a data-primary="springs" data-type="indexterm"></a>

<p>In <a href="#Capítulo03_section6">section 3.6</a>, we looked at modeling simple harmonic motion by mapping the sine wave to a pixel range. <a href="#Capítulo03_exercise6">Exercise 3.6</a> asked you to use this technique to create a simulation of a bob hanging from a spring. While using the <code>sin()</code> function is a quick-and-dirty, one-line-of-code way of getting something up and running, it won’t do if what we really want is to have a bob hanging from a spring in a two-dimensional space that responds to other forces in the environment (wind, gravity, etc.) To accomplish a simulation like this (one that is identical to the pendulum example, only now the arm is a springy connection), we need to model the forces of a spring using <code>PVector</code>.</p>

<figure id="Capitulo03_figure14"><img alt="Figure 3.14" src="capitulo03/ch03_14.png" />
<figcaption>Figure 3.14</figcaption>
</figure>

<a data-primary="forces" data-secondary="Hooke's law" data-type="indexterm"></a> <a data-primary="Hooke's law" data-type="indexterm"></a> <a data-primary="Hooke" data-secondary="Robert" data-type="indexterm"></a> <a data-primary="springs" data-secondary="Hooke's law" data-type="indexterm"></a>

<p>The force of a spring is calculated according to Hooke’s law, named for Robert Hooke, a British physicist who developed the fórmula in 1660. Hooke originally stated the law in Latin: "<em>Ut tensio, sic vis</em>," or “As the extension, so the force.” Let’s think of it this way:</p>

<p><span class="highlight">The force of the spring is directly proportional to the extension of the spring.</span></p>

<figure class="half-width-right" id="Capitulo03_figure15"><img alt="Figure 3.15: x = current length - rest length" src="capitulo03/ch03_15.png" />
<figcaption>Figure 3.15: x = current length - rest length&nbsp;</figcaption>
</figure>

<p>In other words, if you pull on the bob a lot, the force will be strong; if you pull on the bob a little, the force will be weak. Mathematically, the law is stated as follows:</p>

<a data-primary="Hooke's law" data-secondary="fórmula for expressing" data-type="indexterm"></a>

<p><span class="fórmula">F<sub>spring</sub> = - k <code>*</code> x</span></p>

<ul>
	<li>
	<p><code>k</code> is constant and its value will ultimately scale the force. Is the spring highly elastic or quite rigid?</p>
	</li>
	<li>
	<p><code>x</code> refers to the displacement of the spring, i.e. the difference between the current length and the rest length. The rest length is defined as the length of the spring in a state of equilibrium.</p>
	</li>
</ul>

<p>Now remember, force is a vector, so we need to calculate both magnitude and direction. Let’s look at one more diagram of the spring and label all the givens we might have in a Processing sketch.</p>

<figure id="Capitulo03_figure16"><img alt="Figure 3.16" src="capitulo03/ch03_16.png" />
<figcaption>Figure 3.16</figcaption>
</figure>

<p>Let’s establish the following three variables as shown in Figure 3.16.</p>

<pre data-code-language="java" data-type="programlisting" class="codesplit">
PVector anchor;
PVector position;
float restLength;</pre>

<a data-primary="springs" data-secondary="magnitude of force" data-tertiary="determining" data-type="indexterm"></a>

<p>First, let’s use Hooke’s law to calculate the magnitude of the force. We need to know <code>k</code> and <code>x</code>. <code>k</code> is easy; it’s just a constant, so let’s make something up.</p>

<pre data-code-language="java" data-type="programlisting" class="codesplit">
float k = 0.1;</pre>

<a data-primary="springs" data-secondary="rest length" data-type="indexterm"></a>

<p><code>x</code> is perhaps a bit more difficult. We need to know the “difference between the current length and the rest length.” The rest length is defined as the variable <code>restLength</code>. What’s the current length? The distance between the anchor and the bob. And how can we calculate that distance? How about the magnitude of a vector that points from the anchor to the bob? (Note that this is exactly the same process we employed when calculating distance in Example 2.9: gravitational attraction.)</p>

<pre data-code-language="java" data-type="programlisting" class="codesplit">
//{!1} A vector pointing from anchor to bob gives us the current length of the spring.
PVector dir = PVector.sub(bob, anchor);
float currentLength = dir.mag();
float x = currentLength - restLength;</pre>

<a data-primary="springs" data-secondary="direction of force" data-tertiary="determining" data-type="indexterm"></a>

<p>Now that we’ve sorted out the elements necessary for the magnitude of the force (-1 * <code>k</code> * <code>x</code>), we need to figure out the direction, a unit vector pointing in the direction of the force. The good news is that we already have this vector. Right? Just a moment ago we thought to ourselves: “How we can calculate that distance? How about the magnitude of a vector that points from the anchor to the bob?” Well, that is the direction of the force!</p>

<figure id="Capitulo03_figure17"><img alt="Figure 3.17" src="capitulo03/ch03_17.png" />
<figcaption>Figure 3.17</figcaption>
</figure>

<p>In Figure 3.17, we can see that if we stretch the spring beyond its rest length, there should be a force pulling it back towards the anchor. And if it shrinks below its rest length, the force should push it away from the anchor. This reversal of direction is accounted for in the fórmula with the -1. And so all we need to do is normalize the <code>PVector</code> we used for the distance calculation! Let’s take a look at the code and rename that <code>PVector</code> variable as “force.”</p>

<pre data-code-language="java" data-type="programlisting" class="codesplit">
//{!4} Magnitude of spring force according to Hooke’s law
float k = 0.1;
PVector force = PVector.sub(bob, anchor);
float currentLength = force.mag();
float x = currentLength - restLength;

//{!1} Direction of spring force (unit vector)
force.normalize();

// Putting it together: direction and magnitude!
force.mult(-1 * k * x);</pre>

<a data-primary="object-oriented programming" data-secondary="structures" data-tertiary="choosing between" data-type="indexterm"></a>

<p>Now that we have the algorithm worked out for computing the spring force vector, the question remains: what object-oriented programming structure should we use? This, again, is one of those situations in which there is no “correct” answer. There are several possibilities; which one we choose depends on the program’s goals and one’s own personal coding style. Still, since we’ve been working all along with a <code>Mover</code> class, let’s keep going with this same framework. Let’s think of our <code>Mover</code> class as the spring’s “bob.” The bob needs <code>position</code>, <code>velocity</code>, and <code>acceleration</code> vectors to move about the screen. Perfect—we’ve got that already! And perhaps the bob experiences a gravity force via the <code>applyForce()</code> function. Just one more step—we need to apply the spring force:</p>

<pre data-code-language="java" data-type="programlisting" class="codesplit">
Bob bob;

void setup() {
  bob = new Bob();
}

void draw()  {
  //{!1} Our Capítulo 2 “make-up-a-gravity force”
  PVector gravity = new PVector(0, 1);
  bob.applyForce(gravity);
  //{!2 .bold} We need to also calculate and apply a spring force!
  PVector springForce = _______________????
  bob.applyForce(spring);

  //{!2} Our standard update() and display() functions
  bob.update();
  bob.display();
}</pre>

<figure id="Capitulo03_figure18"><img alt="Figure 3.18" src="capitulo03/ch03_18.png" />
<figcaption>Figure 3.18</figcaption>
</figure>

<p>One option would be to write out all of the spring force code in the main <code>draw()</code> loop. But thinking ahead to when you might have multiple bobs and multiple spring connections, it makes a good deal of sense to write an additional class, a <code>Spring</code> class. As shown in Figure 3.18, the <code>Bob</code> class keeps track of the movements of the bob; the <code>Spring</code> class keeps track of the spring’s anchor and its rest length and calculates the spring force on the bob.</p>

<p>This allows us to write a lovely main program as follows:</p>

<pre data-code-language="java" data-type="programlisting" class="codesplit">
Bob bob;
//{!1 .bold} Adding a Spring object
Spring spring;

void setup() {
  bob = new Bob();
  spring = new Spring();
}

void draw()  {
  PVector gravity = new PVector(0,1);
  bob.applyForce(gravity);

  //{!1 .bold} This new function in the Spring class will take care of computing the force of the spring on the bob.
  spring.connect(bob);

  bob.update();
  bob.display();
  spring.display();
}</pre>

<p>You may notice here that this is quite similar to what we did in <a href="#Capítulo02_example6">Example 2.6</a> with an attractor. There, we said something like:</p>

<pre data-code-language="java" data-type="programlisting" class="codesplit">
  PVector force = attractor.attract(mover);
  mover.applyForce(force);</pre>

<p>The analogous situation here with a spring would be:</p>

<pre data-code-language="java" data-type="programlisting" class="codesplit">
  PVector force = spring.connect(bob);
  bob.applyForce(force);</pre>

<p>Nevertheless, in this example all we said was:</p>

<pre data-code-language="java" data-type="programlisting" class="codesplit">
  spring.connect(bob);</pre>

<p>What gives? Why don’t we need to call <code>applyForce()</code> on the bob? The answer is, of course, that we do need to call <code>applyForce()</code> on the bob. Only instead of doing it in <code>draw()</code>, we’re just demonstrating that a perfectly reasonable (and sometimes preferable) alternative is to ask the <code>connect()</code> function to internally handle calling <code>applyForce()</code> on the bob.</p>

<pre data-code-language="java" data-type="programlisting" class="codesplit">
  void connect(Bob b) {
    PVector force = some fancy calculations

    //{!1} The function connect() takes care of calling applyForce() and therefore doesn’t have to return a vector to the calling area.
    b.applyForce(force);
  }</pre>

<p>Why do it one way with the <code>Attractor</code> class and another way with the <code>Spring</code> class? When we were first learning about forces, it was a bit clearer to show all the forces being applied in the main <code>draw()</code> loop, and hopefully this helped you learn about force accumulation. Now that we’re more comfortable with that, perhaps it’s simpler to embed some of the details inside the objects themselves.</p>

<p>Let’s take a look at the rest of the elements in the <code>Spring</code> class.</p>

<figure class="screenshot" data-pde="processingjs/Chapter03/_3_11_spring/_3_11_spring.pde processingjs/Chapter03/_3_11_spring/Mover.pde processingjs/Chapter03/_3_11_spring/Spring.pde"><img alt="ch03 ex11" src="capitulo03/ch03_ex11.png" />
<figcaption>&nbsp;</figcaption>
</figure>

<div data-type="example"><h5>Example 3.11: A Spring connection</h5></div>

<pre data-code-language="java" data-type="programlisting" class="codesplit">
class Spring {

  //{!1} We need to keep track of the spring’s anchor position.
  PVector anchor;

  //{!2} Rest length and spring constant variables
  float len;
  float k = 0.1;

  //{!4} The constructor initializes the anchor point and rest length.
  Spring(float x, float y, int l) {
    anchor = new PVector(x,y);
    len = l;
  }

  //{!1} Calculate spring force—our implementation of Hooke’s Law.
  void connect(Bob b) {

    //{!1 .bold .code-wide} Get a vector pointing from anchor to Bob position.
    PVector force = PVector.sub(b.position, anchor);
    //{!2 .bold} Calculate the displacement between distance and rest length.
    float d = force.mag();
    float stretch = d - len;

    //{!2 .bold} Direction and magnitude together!
    force.normalize();
    force.mult(-1 * k * stretch);

    //{!1} Call applyForce() right here!
    b.applyForce(force);
  }

  //{!5} Draw the anchor.
  void display() {
    fill(100);
    rectMode(CENTER);
    rect(anchor.x,anchor.y,10,10);
  }

  //{!4} Draw the spring connection between Bob position and anchor.
  void displayLine(Bob b) {
    stroke(255);
    line(b.position.x,b.position.y,anchor.x,anchor.y);
  }
}</pre>

<p>The full code for this example is included on the book website, and the Web version also incorporates two additional features: (1) the <code>Bob</code> class includes functions for mouse interactivity so that the bob can be dragged around the window, and (2) the <code>Spring</code> object includes a function to constrain the connection’s length between a minimum and a maximum.</p>

<div data-type="exercise" id="Capitulo03_exercise15">
<h5>Exercise 3.15</h5>

<p>Before running to see the example online, take a look at this constrain function and see if you can fill in the blanks.</p>

<pre data-code-language="java" data-type="programlisting" class="codesplit">
void constrainLength(Bob b, float minlen, float maxlen) {
  //{!1} Vector pointing from Bob to Anchor
  PVector dir = PVector.sub(______,______);
  float d = dir.mag();

  //{!1} Is it too short?
  if (d &lt; minlen) {
    dir.normalize();
    dir.mult(________);
    //{!1} Keep position within constraint.
    b.position = PVector.add(______,______);
    b.velocity.mult(0);
  //{!1} Is it too long?
  } else if (____________) {
    dir.normalize();
    dir.mult(_________);
    //{!1} Keep position within constraint.
    b.position = PVector.add(______,______);
    b.velocity.mult(0);
  }
}</pre>
</div>

<div data-type="exercise" id="Capitulo03_exercise16">
<h5>Exercise 3.16</h5>

<p>Create a system of multiple bobs and spring connections. How would you have a bob connected to a bob with no fixed anchor?</p>
</div>

<div data-type="tip">
<h2>The Ecosystem Project</h2>

<p>Step 3 Exercise:</p>

<p>Take one of your creatures and incorporate oscillation into its motion. You can use the <code>Oscillator</code> class from Example 3.7 as a model. The <code>Oscillator</code> object, however, oscillates around a single point (the middle of the window). Try oscillating around a moving point. In other words, design a creature that moves around the screen according to position, velocity, and acceleration. But that creature isn’t just a static shape, it’s an oscillating body. Consider tying the speed of oscillation to the speed of motion. Think of a butterfly’s flapping wings or the legs of an insect. Can you make it appear that the creature’s internal mechanics (oscillation) drive its locomotion? For a sample, check out the “AttractionArrayWithOscillation” example with the code download.</p>
</div>
</section>
</section>
